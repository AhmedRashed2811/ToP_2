{% extends 'ToP/base.html' %}
{% load static %}
{% block title %}Inventory Model{% endblock %}
{% block content %}
    <meta charset="UTF-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script>Chart.register(ChartDataLabels);</script>

    
    <style>
      /* --- Base & Utility Styles --- */

      @media (min-width: 576px) {
        .container{
              max-width: 100%;
          }
      }

      html, body {
        scroll-behavior: smooth;
      }
      body {
        margin: 0;
        padding: 0;
        background-color: #f8f9fa;
      }
      .hidden {
        display: none;
      }
      body.modal-open {
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
      }
      
      /* --- Header & Page Controls --- */
      .header {
        background-color: #f5f5f5;
        text-align: center;
        padding: 1rem;
        font-size: 24px;
        font-weight: bold;
      }
      .controls {
        display: flex; /* Changed from ruby-text for better compatibility */
        flex-wrap: wrap; /* Allow wrapping on small screens */
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        background-color: #eaeaea;
        gap: 10px;
      }
      .controls select {
        padding: 0.5rem;
        font-size: 16px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
      .controls button {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s ease;
      }
      /* --- Navigation Buttons --- */
      .buttons {
        position: fixed;
        bottom: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
        z-index: 1000;
      }
      .buttons button {
        background-color: #007bff;
        color: white;
        font-size: 14px;
      }
      .buttons button:hover {
        background-color: #0056b3;
      }
      .buttons button.active {
        background-color: #003f7f;
      }

      /* --- Main Dashboard Layout --- */
      .content {
        padding: 2rem;
      }
      .section {
        display: none;
      }
      .active-section {
        display: block;
      }
      .dashboard-container {
        padding: 20px;
        background-color: #f8f9fa;
        min-height: 100vh;
      }
      .dashboard-header {
        display: flex;
        flex-wrap: wrap; /* Allow wrapping */
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #e0e0e0;
        gap: 10px; /* Add gap for wrapping */
      }
      .dashboard-header h2 {
        color: #333;
        font-weight: 600;
        margin: 0;
      }
      .dashboard-controls {
        display: flex;
        gap: 15px;
        align-items: center;
      }
      .refresh-btn {
        background-color: #D2691E;
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 14px;
      }
      .refresh-btn:hover {
        background-color: #a0522d; /* Darker shade of D2691E */
      }
      #downloadReportBtn {
        background-color: #28a745;
        color: white;
      }
      #downloadReportBtn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
      }
      #downloadReportBtn .fa-spinner {
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      #collapseAllBtn { background-color: #6c757d; color: white; }
      #expandAllBtn { background-color: #28a745; color: white; }
      #downloadBtn { background-color: #ffc107; color: black; }

      /* --- Filter Cards --- */
      .filter-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
      }
      .filter-card {
        background-color: white;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        overflow: hidden;
      }
      .filter-card h3 {
        font-size: 14px;
        margin-top: 0;
        margin-bottom: 10px;
        color: #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .filter-toolbar {
        display: flex;
        gap: 8px;
      }
      .filter-bulk-btn,
      .micro-btn {
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background: #f8f9fa;
        cursor: pointer;
        font-size: 12px;
        color: black;
      }
      .filter-bulk-btn:hover,
      .micro-btn:hover {
        background: #eef2f7;
      }
      .filter-bulk-btn.outline,
      .micro-btn.outline {
        background: white;
        color: black;
      }
      .filter-expand-btn {
        background: none;
        border: none;
        font-size: 12px;
        cursor: pointer;
        padding: 2px 4px;
        margin-left: 8px;
        color: #666;
      }
      .filter-expand-btn:hover {
        color: #D2691E;
      }
      .filter-options {
        max-height: 150px;
        overflow-y: auto;
        padding-right: 5px;
        padding-left: 5px;
        display: none; /* Initially hidden */
      }
      .filter-options.active {
        display: block;
      }
      .filter-options label {
        display: block;
        padding: 4px 0;
        font-size: 13px;
        cursor: pointer;
        user-select: none;
      }
      .filter-options input[type="checkbox"] {
        margin-right: 8px;
      }

      /* --- KPI Cards --- */
      .kpi-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
      }
      .kpi-card {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        border-left: 4px solid #D2691E;
      }
      .kpi-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .kpi-title {
        font-size: 14px;
        color: #666;
        font-weight: 500;
      }
      .kpi-icon {
        color: #D2691E;
        font-size: 18px;
      }
      .kpi-value {
        font-size: 28px;
        font-weight: 600;
        color: #333;
        margin-bottom: 5px;
      }
      .kpi-subtext {
        font-size: 12px;
        color: #666;
        margin-top: 2px;
      }
      .kpi-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }
      .kpi-sub-item {
        flex: 1;
        text-align: center;
        padding: 0 5px;
      }
      .kpi-sub-title {
        font-size: 12px;
        color: #666;
        margin-bottom: 2px;
        font-weight: 500;
      }
      .kpi-value-small {
        font-size: 16px;
        font-weight: 600;
        color: #333;
      }
      .kpi-trend {
        display: flex;
        align-items: center;
        font-size: 12px;
      }
      .trend-value {
        margin-right: 5px;
      }
      .trend-up {
        color: #28a745;
      }
      .trend-down {
        color: #dc3545;
      }
      
      /* --- Chart Cards --- */
      .chart-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
      }
      .chart-card {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        position: relative; /* For overlays */
      }
      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .chart-header h3 {
        font-size: 16px;
        margin: 0;
        color: #333;
      }
      .chart-actions {
        display: flex;
        gap: 5px;
      }
      .chart-btn {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 14px;
        padding: 5px;
      }
      .chart-btn:hover {
        color: #D2691E;
      }
      canvas {
        width: 100% !important;
        height: 250px !important;
        background-color: white !important; /* For PDF capture */
      }
      .chartjs-container {
        flex: 1; 
        position: relative;
      }
      
      /* --- Date Range & Period Selectors (Sales & Delivery) --- */
      #dateRangeOverlay,
      #deliveryDateRangeOverlay {
        position: absolute;
        top: -49px;
        right: 67px;
        display: flex;
        gap: 6px;
        align-items: center;
        z-index: 2;
        flex-wrap: wrap;
        justify-content: flex-end;
        max-width: 100%;
      }
      #dateRangeOverlay input[type="date"],
      #deliveryDateRangeOverlay input[type="date"] {
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
        min-width: 120px;
        max-width: 140px;
        flex-shrink: 1;
      }
      #dateRangeOverlay .micro-btn,
      #deliveryDateRangeOverlay .micro-btn,
      #deliveryDateRangeOverlay .delivery-micro-btn {
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        flex-shrink: 0;
      }
      #applyDateRange,
      #applyDeliveryDateRange {
        background: #D2691E;
        color: #fff;
        border: none;
      }
      #clearDateRange,
      #clearDeliveryDateRange {
        background: #f8f9fa;
        border: 1px solid #ddd;
        color: #333;
      }

      #periodSelector,
      #deliveryPeriodSelector {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        gap: 6px;
        z-index: 3;
        background: rgba(255, 255, 255, 0.95);
        padding: 8px;
        border-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        border: 1px solid #e0e0e0;
      }
      .period-btn,
      .delivery-period-btn {
        padding: 6px 10px;
        border: 1px solid #ddd;
        background: white;
        color: #333;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        white-space: nowrap;
        transition: all 0.2s ease;
        font-weight: 500;
      }
      .period-btn:hover,
      .delivery-period-btn:hover {
        background: #f0f0f0;
        border-color: #D2691E;
      }
      .period-btn.active,
      .delivery-period-btn.active {
        background: #D2691E;
        color: white;
        border-color: #D2691E;
      }
      .chart-card canvas {
        height: 220px !important; /* Adjust canvas height to accommodate controls */
      }

      /* --- Unit Metrics Charts --- */
      .unit-metrics-charts-container {
        margin-top: 30px;
        padding: 20px 0;
      }
      .unit-metrics-charts-container h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        font-weight: 500;
        border-left: 4px solid #28a745;
        padding-left: 15px;
      }
      .unit-metrics-chart-wrapper {
        border: 1px solid #e9ecef;
        border-radius: 5px;
        background: #fafafa;
        height: 400px;
        position: relative;
        margin: 0 auto;
        overflow: hidden;
      }
      .unit-metrics-chart-canvas-container {
        width: 100%;
        height: calc(100% - 30px);
        overflow-x: auto;
        overflow-y: hidden;
        position: relative;
        -webkit-overflow-scrolling: touch;
      }
      canvas.unit-metrics-chart {
        width: 100% !important;
        height: 100% !important;
        min-width: 600px;
      }
      .unit-metrics-value-box {
        position: absolute;
        background-color: white;
        color: black;
        border: 1px solid #666666;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
        white-space: nowrap;
        pointer-events: none;
        width: 55px;
        height: 18px;
        z-index: 5;
        padding: 1px;
        box-sizing: border-box;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        transform: translate(-50%, -50%); /* Center the box */
      }
      .unit-metrics-value-box.avg {
        background-color: #D2691E;
        color: white;
        border: 1px solid #A0522D;
      }

      /* --- Data Table --- */
      .table-container {
        background-color: white;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        margin-bottom: 20px;
        position: relative;
        overflow: auto; /* Changed from hidden */
        -webkit-overflow-scrolling: touch;
      }
      .table-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        position: relative;
      }
      .table-header h3 {
        font-size: 16px;
        margin: 0;
        color: #333;
      }
      .export-btn {
        background-color: #28a745;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 13px;
      }
      .export-btn:hover {
        background-color: #218838;
      }
      .table-toggle-container {
        display: flex;
        justify-content: center;
        width: 100%;
        position: absolute;
        bottom: -10px;
        left: 0;
        z-index: 10;
      }
      .table-toggle-btn {
        background-color: #D2691E;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      }
      .table-toggle-btn:hover {
        background-color: #a0522d;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      }
      .table-toggle-btn i {
        transition: transform 0.3s ease;
      }
      .table-toggle-btn.expanded i {
        transform: rotate(180deg);
      }
      .table-scroll {
        overflow-x: auto;
        transition: max-height 0.5s ease, opacity 0.3s ease;
        max-height: 0;
        opacity: 0;
      }
      .table-scroll.expanded {
        max-height: 1000px;
        opacity: 1;
        margin-top: 15px;
      }
      #unitsTable {
        width: 100%;
        min-width: 600px;
        border-collapse: collapse;
      }
      #unitsTable th, #unitsTable td {
        padding: 10px 15px;
        text-align: left;
        border-bottom: 1px solid #eee;
        font-size: 13px;
      }
      #unitsTable th {
        background-color: #f5f5f5;
        font-weight: 600;
        color: #333;
        position: sticky;
        top: 0;
      }
      #unitsTable tr:hover {
        background-color: #f9f9f9;
      }
      
      /* --- Pivot Table Styles --- */
      .toggle {
        color: #007bff;
        font-weight: bold;
        cursor: pointer;
        font-size: 14px;
        user-select: none;
      }
      table {
        width: max-content;
        min-width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
        font-size: 14px;
      }
      th, td {
        padding: 10px;
        text-align: center;
        vertical-align: middle;
      }
      th {
        background-color: #f0f0f0;
      }
      tr:hover {
        background-color: #f9f9f9;
      }
      .left-border {
        border-left: 2px solid #ccc;
        border-bottom: none;
      }
      .right-border {
        border-right: 2px solid #ccc;
        border-bottom: none;
      }
      .group-label {
        display: flex;
        align-items: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-align: left;
      }
      .year-group {
        border-left: 5px solid #ddd;
      }
      .month-group {
        border-left: 2px solid #eee;
      }
      .year-toggle {
        color: white;
        background: none;
        border: none;
        cursor: pointer;
        font-weight: bold;
        padding: 5px;
      }
      .year-toggle:hover {
        background-color: rgba(255,255,255,0.1);
      }
      th:first-child,
      td:first-child {
        position: sticky;
        left: 0;
        background: white;
        z-index: 2;
        text-align: left;
        border-right: 1px solid #ccc;
      }

      /* --- Modal Styles --- */
      .chart-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.9);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
        overflow: auto;
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        pointer-events: auto;
      }
      .chart-modal-container {
        position: relative;
        background: white;
        padding: 30px;
        border-radius: 12px;
        max-width: 95vw;
        max-height: 95vh;
        overflow: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        width: auto;
        min-width: 300px;
        animation: modalAppear 0.3s ease-out;
        pointer-events: auto;
      }
      @keyframes modalAppear {
        from { opacity: 0; transform: scale(0.9); }
        to { opacity: 1; transform: scale(1); }
      }
      .chart-modal-close {
        position: absolute;
        top: 15px;
        right: 15px;
        background: #dc3545;
        color: white;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2001;
        transition: background-color 0.2s ease;
      }
      .chart-modal-close:hover {
        background-color: #c82333;
      }
      .chart-modal-container h3 {
        margin: 0 0 20px 0;
        color: #333;
        font-size: 24px;
        font-weight: 600;
        text-align: center;
        width: 100%;
      }
      .chart-modal .unit-metrics-chart-wrapper {
        height: 500px !important;
        width: 100% !important;
        overflow: hidden;
      }
      .chart-modal .unit-metrics-chart-canvas-container {
        height: 100% !important;
        width: 100% !important;
        overflow-x: auto;
        overflow-y: hidden;
      }
      .chart-modal canvas.unit-metrics-chart {
        width: 100% !important;
        height: 100% !important;
        min-width: 1200px;
      }
      .chart-modal .chartjs-tooltip {
        z-index: 2002 !important;
        position: absolute;
        pointer-events: none;
      }
      .chart-modal .chartjs-tooltip-key {
        display: inline-block;
        width: 10px;
        height: 10px;
        margin-right: 5px;
      }
      
      /* --- Loader Styles --- */
      .dashboard-loader {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      
      .loader-spinner {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #D2691E;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
      }

      /* --- Print Styles --- */
      @media print {
        #dateRangeOverlay,
        #deliveryDateRangeOverlay,
        #periodSelector,
        #deliveryPeriodSelector,
        .buttons,
        .controls,
        .dashboard-header,
        .filter-container,
        .table-container {
          display: none;
        }
        .chart-card {
          break-inside: avoid;
          box-shadow: none;
          border: 1px solid #ccc;
        }
        .content {
          padding: 0;
        }
      }

      /* =====================================================================
      == RESPONSIVE MEDIA QUERIES
      =====================================================================
      */
      
      /* --- Large Desktops --- */
      @media (min-width: 1200px) {
        .container, .container-lg, .container-md, .container-sm, .container-xl {
            max-width: 100%;
        }
      }

      /* --- Tablets & Small Desktops --- */
      @media (max-width: 1200px) {
        #dateRangeOverlay, #deliveryDateRangeOverlay {
            gap: 4px;
        }
        #dateRangeOverlay input[type="date"], #deliveryDateRangeOverlay input[type="date"] {
            min-width: 110px;
            max-width: 130px;
            padding: 5px 6px;
            font-size: 11px;
        }
        #dateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .delivery-micro-btn {
            padding: 5px 8px;
            font-size: 11px;
        }
        #periodSelector, #deliveryPeriodSelector {
            gap: 4px;
            padding: 6px;
        }
        .period-btn, .delivery-period-btn {
            padding: 5px 8px;
            font-size: 10px;
        }
        .chart-container .chart-card[style*="grid-template-columns: 70% 30%"] {
          grid-template-columns: 1fr !important;
          gap: 20px;
        }
      }

      /* --- Tablets (Portrait) --- */
      @media (max-width: 768px) {
        .content {
          padding: 1rem;
        }
        .dashboard-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }
        .filter-container,
        .chart-container {
          grid-template-columns: 1fr;
        }
        .kpi-container {
          grid-template-columns: 1fr 1fr;
        }
        .filter-card h3 {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
        }
        .filter-toolbar,
        .filter-card h3 span {
          align-self: flex-end;
        }
        
        /* Move overlays to be relative */
        #dateRangeOverlay, #deliveryDateRangeOverlay {
          position: relative;
          top: auto;
          right: auto;
          justify-content: center;
          margin-bottom: 10px;
          padding: 8px;
          background: rgba(255, 255, 255, 0.95);
          border-radius: 6px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        #dateRangeOverlay input[type="date"], #deliveryDateRangeOverlay input[type="date"] {
            min-width: 100px;
            max-width: 120px;
            font-size: 10px;
            padding: 4px 5px;
        }
        #dateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .delivery-micro-btn {
            padding: 4px 6px;
            font-size: 10px;
        }
        
        /* Move period selectors to be relative */
        #periodSelector, #deliveryPeriodSelector {
          position: relative;
          bottom: auto;
          right: auto;
          justify-content: center;
          margin-top: 10px;
          margin-bottom: 5px;
          width: fit-content;
          margin-left: auto;
          margin-right: auto;
        }
        .period-btn, .delivery-period-btn {
            padding: 6px 10px;
            font-size: 11px;
        }
        
        .chart-card canvas {
            height: 100% !important;
            max-height: 380px;
        }
        .table-toggle-container {
          position: relative;
          bottom: 0;
          margin-top: 10px;
        }
        .table-scroll.expanded {
          margin-top: 10px;
        }
        
        /* Modal on Tablet */
        .chart-modal { padding: 10px; }
        .chart-modal-container {
          padding: 20px;
          max-width: 98%;
          max-height: 98%;
        }
        .chart-modal-close {
          width: 35px !important;
          height: 35px !important;
          font-size: 20px !important;
          top: 10px !important;
          right: 10px !important;
        }
        .chart-modal-container h3 {
          font-size: 20px !important;
          margin-bottom: 15px !important;
        }
        .chart-modal .unit-metrics-chart-wrapper {
          min-width: 600px;
          height: 400px !important;
        }
        .chart-modal canvas.unit-metrics-chart {
          min-width: 600px;
        }
        
        .unit-metrics-chart-wrapper { height: 350px; }
        .unit-metrics-value-box { font-size: 10px; width: 50px; height: 16px; }
        .unit-metrics-chart-canvas-container { height: calc(100% - 25px); }

        canvas.unit-metrics-chart {
            min-width: 360px;
        }
      }
      
      /* --- Mobile Phones --- */
      @media (max-width: 480px) {
        .content {
          padding: 0.5rem;
        }
        .kpi-container,
        .filter-container {
          grid-template-columns: 1fr;
        }
        .filter-card { padding: 8px; }
        .filter-options label { font-size: 12px; }
        .micro-btn, .filter-bulk-btn, .filter-expand-btn {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        /* Stack overlays vertically */
        #dateRangeOverlay, #deliveryDateRangeOverlay {
          flex-direction: column;
          align-items: stretch;
          gap: 6px;
          width: 90%;
          margin-left: auto;
          margin-right: auto;
        }
        #dateRangeOverlay input[type="date"], #deliveryDateRangeOverlay input[type="date"] {
            min-width: auto;
            max-width: none;
            width: 100%;
            font-size: 12px;
            padding: 8px;
        }
        #dateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .delivery-micro-btn {
            padding: 8px 12px;
            font-size: 12px;
            width: 100%;
        }
        .chart-card[style*="padding-top: 80px"] { /* Overriding inline style */
             padding-top: 15px !important; 
        }
        .delivery-chart-card {
            position: relative;
            padding-top: 15px !important; /* Make space for the overlay when it moves */
        }
        
        /* Stack period selectors vertically */
        #periodSelector, #deliveryPeriodSelector {
          flex-direction: column;
          width: 90%;
          gap: 5px;
        }
        .period-btn, .delivery-period-btn {
            width: 100%;
            padding: 8px 12px;
            font-size: 12px;
        }
        
        .unit-metrics-chart-wrapper { height: 300px; }
        .unit-metrics-value-box { font-size: 9px; width: 45px; height: 14px; }
        canvas.unit-metrics-chart { min-width: 10px; }
        
        .chart-modal .unit-metrics-chart-wrapper { height: 350px !important; }
        .chart-modal canvas.unit-metrics-chart { min-width: 600px !important; }
      }
      
      /* --- Landscape Mobile --- */
      @media (max-height: 500px) and (orientation: landscape) {
        #dateRangeOverlay, #deliveryDateRangeOverlay {
            position: absolute;
            top: -17px;
            right: 6px;
            flex-direction: row;
            width: auto;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px;
        }
        #dateRangeOverlay input[type="date"], #deliveryDateRangeOverlay input[type="date"] {
            width: auto;
            min-width: 100px;
        }
        #dateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .micro-btn, #deliveryDateRangeOverlay .delivery-micro-btn {
            width: auto;
        }
        #periodSelector, #deliveryPeriodSelector {
            position: absolute;
            bottom: 5px;
            right: 5px;
            flex-direction: row;
            width: auto;
        }
        .period-btn, .delivery-period-btn {
            width: auto;
            padding: 4px 8px;
            font-size: 10px;
        }
      }

      /* Add inside your <style> block */

      #unitsTable tfoot {
          font-weight: bold;
          background-color: #e9ecef; /* Light gray background to stand out */
          border-top: 2px solid #999;
          position: sticky;
          bottom: 0;
          z-index: 5; /* Ensure it stays above scrolling rows */
          box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
      }

      #unitsTable tfoot td {
          padding: 12px 15px;
          color: #333;
      }

    </style>

    
    <div class="controls">
      {% if not selected_company_id %}
      <!-- Show dropdown for non-managers -->
      <select id="companySelect" onchange="loadCompanyUnits()">
        <option value="">-- Select Company --</option>
        {% for company in companies %}
          <option value="{{ company.id }}" {% if company.id == selected_company_id %}selected{% endif %}>
            {{ company.name }}
          </option>
        {% endfor %}
      </select>
      {% else %}
        <!-- Show text label for managers -->
        <span style="font-weight: bold;">Company: 
          {% for company in companies %}
            {% if company.id == selected_company_id %}
              {{ company.name }}
            {% endif %}
          {% endfor %}
        </span>
      {% endif %}
      <!-- Add Download Report Button -->
      <button id="downloadReportBtn" onclick="downloadDashboardReport()" 
        style="margin-left: 10px; padding: 0.5rem 1rem; background-color: #28a745; color: white; border: none; border-radius: 4px; font-weight: bold;">
      <i class="fas fa-download"></i> Report
      </button>
      <div id="yearControls" style="display: none;">
        <button id="collapseAllBtn" onclick="collapseAllYears()" style="margin-left: 10px; padding: 0.5rem 1rem; background-color: #6c757d; color: white; border: none; border-radius: 4px;">Collapse All Years</button>
        <button id="expandAllBtn" onclick="expandAllYears()" style="margin-left: 5px; padding: 0.5rem 1rem; background-color: #28a745; color: white; border: none; border-radius: 4px;">Expand All Years</button>
      </div>
      <div id="downloadControl" style="display: none;">
        <button id="downloadBtn" onclick="downloadVisibleTable()" style="margin-left: 5px; padding: 0.5rem 1rem; background-color: #ffc107; color: black; border: none; border-radius: 4px;">Download Excel</button>
      </div>
      {% if selected_company_id %}
        <div class="buttons" style="display: flex;">
      {% else %}
        <div class="buttons" style="display: none;">
      {% endif %}
        <button data-section="home" onclick="showSection('home')">Home Page</button>
        <button data-section="project" onclick="showSection('project')">Project Data</button>
        <button data-section="inv" onclick="showSection('inv')">Inv Status</button>
        <button data-section="sales" onclick="showSection('sales')">Sales Progress</button>
        <button data-section="delivery" onclick="showSection('delivery')">Delivery Plan</button>
      </div>
    </div>
    <div class="content">
      <div id="homeSection" class="section active-section">
        <div class="dashboard-container">
          <!-- Dashboard Header -->
          <div class="dashboard-header">
            <h2>Inverntory Dashboard</h2>
            <div class="dashboard-controls">
              <button id="refreshBtn" class="refresh-btn" style="display: none;">
                <i class="fas fa-sync-alt"></i> Refresh
              </button>
            </div>
          </div>
        
          <div class="filter-container">
            <div class="filter-card" style="grid-column: 1 / -1;">
              <div class="table-header" style="margin:0">
                <h3 style="margin:0">Filters</h3>
                <div class="filter-toolbar">
                  <button type="button" class="filter-bulk-btn" onclick="selectAllFilters()">All</button>
                  <button type="button" class="filter-bulk-btn outline" onclick="deselectAllFilters()">Deselect All</button>
                </div>
              </div>
            </div>
        
            <div class="filter-card">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  Project
                  <button class="filter-expand-btn" onclick="toggleFilter('projectFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('projectFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('projectFilter')">None</button>
                </span>
              </h3>
              <div id="projectFilter" class="filter-options"></div>
            </div>
        
            <div class="filter-card">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  Type
                  <button class="filter-expand-btn" onclick="toggleFilter('unitTypeFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('unitTypeFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('unitTypeFilter')">None</button>
                </span>
              </h3>
              <div id="unitTypeFilter" class="filter-options"></div>
            </div>
        
            <div class="filter-card" style="display: none;">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  Contract Payment Plan
                  <button class="filter-expand-btn" onclick="toggleFilter('contractPaymentPlanFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('contractPaymentPlanFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('contractPaymentPlanFilter')">None</button>
                </span>
              </h3>
              <div id="contractPaymentPlanFilter" class="filter-options"></div>
            </div>
        
            <div class="filter-card">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  Status
                  <button class="filter-expand-btn" onclick="toggleFilter('statusFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('statusFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('statusFilter')">None</button>
                </span>
              </h3>
              <div id="statusFilter" class="filter-options"></div>
            </div>
        
            <div class="filter-card">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  Area
                  <button class="filter-expand-btn" onclick="toggleFilter('areaFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('areaFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('areaFilter')">None</button>
                </span>
              </h3>
              <div id="areaFilter" class="filter-options"></div>
            </div>
        
            <div class="filter-card">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  City
                  <button class="filter-expand-btn" onclick="toggleFilter('cityFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('cityFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('cityFilter')">None</button>
                </span>
              </h3>
              <div id="cityFilter" class="filter-options"></div>
            </div>

            <div class="filter-card">
              <h3 style="display:flex;justify-content:space-between;align-items:center;">
                <span>
                  Owners
                  <button class="filter-expand-btn" onclick="toggleFilter('ownerFilter')">[+]</button>
                </span>
                <span>
                  <button class="micro-btn" onclick="selectAllIn('ownerFilter')">All</button>
                  <button class="micro-btn outline" onclick="deselectAllIn('ownerFilter')">None</button>
                </span>
              </h3>
              <div id="ownerFilter" class="filter-options"></div>
            </div>

          </div> 


        
          <!-- KPI Cards Row -->
          <div class="kpi-container">
            <div class="kpi-card">
              <div class="kpi-header">
                <span class="kpi-title">Total Inventory</span>
                <i class="fas fa-building kpi-icon"></i>
              </div>
              <div class="kpi-row">
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Total Units:</div>
                  <div class="kpi-value-small" id="totalInvCount">-</div>
                </div>
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Total Sales Value:</div>
                  <div class="kpi-value-small" id="totalInvValue">-</div>
                </div>
              </div>
              <div class="kpi-row">
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Avg. Sales Value:</div>
                  <div class="kpi-value-small" id="totalInvAvgPrice">-</div>
                </div>
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Avg. PSM:</div>
                  <div class="kpi-value-small" id="totalInvAvgPSM">-</div>
                </div>
              </div>
            </div>
        
            <div class="kpi-card">
              <div class="kpi-header">
                <span class="kpi-title">Sold Units</span>
                <i class="fas fa-check-circle kpi-icon"></i>
              </div>
              <div class="kpi-row">
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Total Units:</div>
                  <div class="kpi-value-small" id="soldCount">-</div>
                </div>
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Total Sales Value:</div>
                  <div class="kpi-value-small" id="soldValue">-</div>
                </div>
              </div>
              <div class="kpi-row">
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Avg. Sales Value:</div>
                  <div class="kpi-value-small" id="soldAvgPrice">-</div>
                </div>
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Avg. PSM:</div>
                  <div class="kpi-value-small" id="soldAvgPSM">-</div>
                </div>
              </div>
            </div>
        
            <div class="kpi-card">
              <div class="kpi-header">
                <span class="kpi-title">Unsold Units</span>
                <i class="fas fa-inventory kpi-icon"></i>
              </div>
              <div class="kpi-row">
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Total Units:</div>
                  <div class="kpi-value-small" id="unsoldCount">-</div>
                </div>
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Total Sales Value:</div>
                  <div class="kpi-value-small" id="unsoldValue">-</div>
                </div>
              </div>
              <div class="kpi-row">
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Avg. Interest-Free Price:</div>
                  <div class="kpi-value-small" id="unsoldAvgPrice">-</div>
                </div>
                <div class="kpi-sub-item">
                  <div class="kpi-sub-title">Avg. PSM:</div>
                  <div class="kpi-value-small" id="unsoldAvgPSM">-</div>
                </div>
              </div>
            </div>
          </div>
        
          <!-- Three Pie Charts Row (updated DOM) -->
          <div class="chart-container" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));">
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Inventory Status</h3>
                    <div class="chart-actions">
                        <button class="chart-btn" onclick="downloadChart(document.getElementById('inventoryChart'))"><i class="fas fa-download"></i></button>
                        <button class="chart-btn" onclick="window.dashboard.expandChart(document.getElementById('inventoryChart'))"><i class="fas fa-expand"></i></button>                    </div>
                </div>
                <canvas id="inventoryChart"></canvas>
            </div>
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Unit Model</h3>
                    <div class="chart-actions">
                        <button class="chart-btn" onclick="downloadChart(document.getElementById('unitModelChart'))"><i class="fas fa-download"></i></button>
                        <button class="chart-btn" onclick="window.dashboard.expandChart(document.getElementById('unitModelChart'))"><i class="fas fa-expand"></i></button>
                    </div>
                </div>
                <canvas id="unitModelChart"></canvas>
            </div>
            <!-- Changed Card for Contract Payment Plan Bar Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Contract Payment Plan</h3>
                    <div class="chart-actions">
                        <button class="chart-btn" onclick="downloadChart(document.getElementById('contractPaymentPlanChart'))"><i class="fas fa-download"></i></button>
                        <button class="chart-btn" onclick="window.dashboard.expandChart(document.getElementById('contractPaymentPlanChart'))"><i class="fas fa-expand"></i></button>
                    </div>
                </div>
                <canvas id="contractPaymentPlanChart"></canvas>
            </div>
          </div>
        
          <!-- Sales Trend (FULL WIDTH) with Date Range overlay in top-right and Period Selector in bottom-right -->
          <div class="chart-container" style="grid-template-columns: 1fr;">
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Sales Trend</h3>
                    <div class="chart-actions">
                        <button class="chart-btn"><i class="fas fa-download"></i></button>
                        <button class="chart-btn"><i class="fas fa-expand"></i></button>
                    </div>
                </div>

                <!-- Chart container with proper spacing -->
                <div style="position:relative; flex: 1; display: flex; flex-direction: column; min-height: 280px;">
                    <!-- Date Range Overlay (Top Right) -->
                    <div id="dateRangeOverlay">
                        <input type="date" id="startDate" aria-label="Start Date">
                        <span style="color: #666; font-size: 12px; white-space: nowrap;">to</span>
                        <input type="date" id="endDate" aria-label="End Date">
                        <button id="applyDateRange" class="micro-btn" style="background:#D2691E; color:#fff; border:none;">Apply</button>
                        <button id="clearDateRange" class="micro-btn outline">Clear</button>
                    </div>
                    
                    <!-- Chart Canvas (Takes most space) -->
                    <div class="chartjs-container" style="flex: 1; position: relative;">
                        <canvas id="salesTrendChart"></canvas>
                    </div>
                    
                    <!-- Period Selector (Bottom Right) -->
                    <div id="periodSelector">
                        <button class="period-btn" data-period="monthly">Monthly</button>
                        <button class="period-btn" data-period="quarterly">Quarterly</button>
                        <button class="period-btn active" data-period="annually">Annually</button>
                    </div>
                </div>
            </div>
          </div>


          <!-- Delivery Progress and Compliance Charts Row (FULL WIDTH) -->
          <div class="chart-container" style="grid-template-columns: 1fr;">
            <div class="chart-card" style="display: grid; grid-template-columns: 70% 30%; gap: 15px;">
              
              <!-- Delivery Analysis (Left - 70%) -->
              <div style="position: relative;">
                <div class="chart-header">
                  <h3>Delivery Analysis</h3>
                  <div class="chart-actions">
                    <button class="chart-btn"><i class="fas fa-download"></i></button>
                    <button class="chart-btn"><i class="fas fa-expand"></i></button>
                  </div>
                </div>
                
                <!-- Chart container with proper spacing -->
                <div style="position:relative; flex: 1; display: flex; flex-direction: column; min-height: 280px;">
                  <!-- Date Range Overlay (Top Right) -->
                  <div id="deliveryDateRangeOverlay">
                    <input type="date" id="deliveryStartDate" aria-label="Start Date">
                    <span style="color: #666; font-size: 12px; white-space: nowrap;">to</span>
                    <input type="date" id="deliveryEndDate" aria-label="End Date">
                    <button id="applyDeliveryDateRange" class="micro-btn" style="background:#D2691E; color:#fff; border:none;">Apply</button>
                    <button id="clearDeliveryDateRange" class="micro-btn outline">Clear</button>
                  </div>
                  
                  <!-- Chart Canvas (Takes most space) -->
                  <div class="chartjs-container" style="flex: 1; position: relative;">
                    <canvas id="deliveryProgressChart"></canvas>
                  </div>
                  
                  <!-- Period Selector (Bottom Right) -->
                  <div id="deliveryPeriodSelector">
                    <button class="period-btn" data-period="monthly">Monthly</button>
                    <button class="period-btn" data-period="quarterly">Quarterly</button>
                    <button class="period-btn active" data-period="annually">Annually</button>
                  </div>
                </div>
              </div>

              <!-- Delivery Timing Compliance Chart (Right - 30%) -->
              <div style="position: relative;">
                <div class="chart-header">
                  <h3>Delivery Timing Compliance</h3>
                  <div class="chart-actions">
                    <button class="chart-btn"><i class="fas fa-download"></i></button>
                    <button class="chart-btn"><i class="fas fa-expand"></i></button>
                  </div>
                </div>
                
                <div style="position:relative; height: 280px; display: flex; align-items: center; justify-content: center;">
                  <canvas id="deliveryComplianceChart"></canvas>
                </div>
              </div>

            </div>
          </div>


          <!-- Add the new Unit Metrics Charts Container here -->
          <div class="unit-metrics-charts-container">
            <h2>Unit Metrics Overview</h2>
            <!-- Remove the surrounding grid container to stack the cards vertically -->
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Unit Price Range</h3>
                    <div class="chart-actions">
                        <!-- Optional: Add download/expand buttons if needed -->
                        <button class="chart-btn"><i class="fas fa-download"></i></button>
                        <button class="chart-btn"><i class="fas fa-expand"></i></button>
                    </div>
                </div>
                <div class="unit-metrics-chart-wrapper">
                    <div class="unit-metrics-chart-canvas-container">
                        <canvas id="unitPriceChart" class="unit-metrics-chart"></canvas>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Price per Square Meter (PSM) Range</h3>
                    <div class="chart-actions">
                        <!-- Optional: Add download/expand buttons if needed -->
                        <button class="chart-btn"><i class="fas fa-download"></i></button>
                        <button class="chart-btn"><i class="fas fa-expand"></i></button>
                    </div>
                </div>
                <div class="unit-metrics-chart-wrapper">
                    <div class="unit-metrics-chart-canvas-container">
                        <canvas id="unitPSMChart" class="unit-metrics-chart"></canvas>
                    </div>
                </div>
            </div>
            <div class="chart-card">
                <div class="chart-header">
                    <h3>Gross Area Range (sqm)</h3>
                    <div class="chart-actions">
                        <!-- Optional: Add download/expand buttons if needed -->
                        <button class="chart-btn"><i class="fas fa-download"></i></button>
                        <button class="chart-btn"><i class="fas fa-expand"></i></button>
                    </div>
                </div>
                <div class="unit-metrics-chart-wrapper">
                    <div class="unit-metrics-chart-canvas-container">
                        <canvas id="unitAreaChart" class="unit-metrics-chart"></canvas>
                    </div>
                </div>
            </div>
          </div>


          

          


        
          <!-- Data Table -->
          <div class="table-container">
            <div class="table-header">
              <h3>Unit Details</h3>
              <div class="table-actions">
                <button id="exportData" class="export-btn">
                  <i class="fas fa-file-export"></i> Export
                </button>
              </div>
            </div>
            
            <div class="table-toggle-container">
              <button id="tableToggleBtn" class="table-toggle-btn">
                <span>Show Details</span>
                <i class="fas fa-chevron-down"></i>
              </button>
            </div>
            
            <div class="table-scroll" id="tableScroll">
              <table id="unitsTable">
                <thead>
                  <tr>
                    <th>Project</th>
                    <th></th>
                    <th>Unit Type</th>
                    <th>Area</th>
                    <th>Status</th>
                    <th>Price</th>
                    <th>Sales Value</th>
                    <th>PSM</th>
                    <th>Delivery Date</th>
                    <th>Reservation Date</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          
          <!-- Add this JavaScript to handle the toggle functionality -->
          <script>
            document.addEventListener('DOMContentLoaded', function() {
              const tableToggleBtn = document.getElementById('tableToggleBtn');
              const tableScroll = document.getElementById('tableScroll');
              
              if (tableToggleBtn && tableScroll) {
                tableToggleBtn.addEventListener('click', function() {
                  const isExpanded = tableScroll.classList.contains('expanded');
                  
                  if (isExpanded) {
                    // Collapse the table
                    tableScroll.classList.remove('expanded');
                    tableToggleBtn.classList.remove('expanded');
                    tableToggleBtn.innerHTML = '<span>Show Details</span><i class="fas fa-chevron-down"></i>';
                  } else {
                    // Expand the table
                    tableScroll.classList.add('expanded');
                    tableToggleBtn.classList.add('expanded');
                    tableToggleBtn.innerHTML = '<span>Hide Details</span><i class="fas fa-chevron-up"></i>';
                  }
                });
              }
            });
          </script>
        </div>    
        
        
      </div>
      <div id="projectSection" class="section">
        <h2>Pivot Table: Units by Status</h2>
        <div class="table-container">
          <div id="pivotTableContainer"></div>
        </div>
      </div>
      <div id="invSection" class="section">
        <h2>Inventory Status</h2>
        <div class="table-container">
          <div id="invPivotTableContainer"></div>
        </div>
      </div>
      <div id="salesSection" class="section">
        <h2>Sales Progress</h2>
        <div class="table-container">
          <div id="salesPivotTableContainer"></div>
        </div>
      </div>
      <div id="deliverySection" class="section">
        <h2>Delivery Plan</h2>
        <div class="table-container">
          <div id="deliveryPivotTableContainer"></div>
        </div>
      </div>
    </div>

    <script>
      // Per-card controls - Updated for checkboxes
      function selectAllIn(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
          container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = true);
        }
        if (window.dashboard) window.dashboard.updateFilters();
      }
      function deselectAllIn(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
          container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
        }
        if (window.dashboard) window.dashboard.updateFilters();
      }
      // Global controls (all filters) - Updated for checkboxes
      function selectAllFilters() {
        document.querySelectorAll('.filter-options input[type="checkbox"]').forEach(checkbox => checkbox.checked = true);
        if (window.dashboard) window.dashboard.updateFilters();
      }
      function deselectAllFilters() {
        document.querySelectorAll('.filter-options input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);
        if (window.dashboard) window.dashboard.updateFilters();
      }
      // NEW: Function to toggle individual filter visibility
      function toggleFilter(containerId) {
        const container = document.getElementById(containerId);
        const button = document.querySelector(`[onclick="toggleFilter('${containerId}')"]`);
        if (container && button) {
          container.classList.toggle('active');
          if (container.classList.contains('active')) {
            button.textContent = '[-]'; // Change to collapse symbol
          } else {
            button.textContent = '[+]'; // Change to expand symbol
          }
        }
      }
    </script>

    <script>
      function downloadVisibleTable() {
        const sectionMap = {
          project: "pivotTableContainer",
          inv: "invPivotTableContainer",
          sales: "salesPivotTableContainer",
          delivery: "deliveryPivotTableContainer"
        };
        const activeSection = document.querySelector(".section.active-section");
        const sectionId = activeSection?.id.replace("Section", "");
        const containerId = sectionMap[sectionId];
        if (!containerId) {
          alert("No data available to download.");
          return;
        }
        const table = document.querySelector(`#${containerId} table`);
        if (!table) {
          alert("Table is not available or empty.");
          return;
        }
        const wb = XLSX.utils.book_new();
        const ws_data = [];
        const merges = [];
        // Only get visible rows (not hidden ones)
        const rows = Array.from(table.querySelectorAll("thead tr")).concat(
          Array.from(table.querySelectorAll("tbody tr:not(.hidden)"))
        );
        let maxCols = 0;
        // Style definitions
        const styles = {
          headerBlue: {
            font: { bold: true, color: { rgb: "FFFFFF" }, sz: 12 },
            fill: { fgColor: { rgb: "D2691E" } }, // Blue
            alignment: { horizontal: "center", vertical: "center", wrapText: true }
          },
          headerGray: {
            font: { bold: true, color: { rgb: "FFFFFF" }, sz: 12 },
            fill: { fgColor: { rgb: "7F7F7F" } }, // Gray
            alignment: { horizontal: "center", vertical: "center", wrapText: true }
          },
          subHeader: {
            font: { bold: true, color: { rgb: "000000" }, sz: 11 },
            fill: { fgColor: { rgb: "D9E1F2" } }, // Light blue
            alignment: { horizontal: "center", vertical: "center" }
          },
          groupHeader: {
            font: { bold: true, color: { rgb: "000000" }, sz: 11 },
            fill: { fgColor: { rgb: "F2F2F2" } }, // Light gray
            alignment: { horizontal: "left" }
          },
          dataCell: {
            font: { color: { rgb: "000000" }, sz: 10 },
            fill: { fgColor: { rgb: "FFFFFF" } }, // White
            alignment: { horizontal: "right" }
          },
          leftBorder: {
            font: { color: { rgb: "000000" }, sz: 10 },
            fill: { fgColor: { rgb: "FFFFFF" } },
            alignment: { horizontal: "right" },
            border: { left: { style: "medium", color: { rgb: "CCCCCC" } } }
          }
        };
        // Process each visible row
        rows.forEach((row, rowIndex) => {
          const rowData = [];
          let colIndex = 0;
          row.querySelectorAll("th, td").forEach((cell) => {
            while (rowData[colIndex]) colIndex++; // Skip merged cells
            const cellValue = cell.innerText.trim();
            const colspan = parseInt(cell.getAttribute("colspan")) || 1;
            const rowspan = parseInt(cell.getAttribute("rowspan")) || 1;
            const isHeader = cell.tagName === "TH";
            const isGroupLabel = cell.querySelector(".group-label");
            const isPercentage = cell.textContent.includes("%") && !isHeader;
            const hasLeftBorder = cell.classList.contains("left-border");
            // Get background color from computed style
            const bgColor = window.getComputedStyle(cell).backgroundColor;
            // Determine cell style
            let cellStyle;
            if (isHeader) {
              if (bgColor.includes("rgb(68, 114, 196)") || bgColor.includes("blue")) {
                cellStyle = styles.headerBlue;
              } else if (bgColor.includes("rgb(127, 127, 127)") || bgColor.includes("gray")) {
                cellStyle = styles.headerGray;
              } else {
                cellStyle = styles.subHeader;
              }
            } else if (isGroupLabel) {
              cellStyle = styles.groupHeader;
              // Apply indentation based on level
              const level = parseInt(cell.querySelector(".group-label").style.paddingLeft) / 30 || 0;
              cellStyle.alignment = { ...cellStyle.alignment, indent: level };
            } else if (hasLeftBorder) {
              cellStyle = styles.leftBorder;
            } else {
              cellStyle = styles.dataCell;
            }
            rowData[colIndex] = {
              v: cellValue,
              t: typeof cellValue === "number" ? "n" : "s",
              s: cellStyle
            };
            if (colspan > 1 || rowspan > 1) {
              merges.push({
                s: { r: rowIndex, c: colIndex },
                e: { r: rowIndex + rowspan - 1, c: colIndex + colspan - 1 }
              });
            }
            colIndex += colspan;
          });
          maxCols = Math.max(maxCols, rowData.length);
          ws_data.push(rowData);
        });
        // Add specific merges for each section type
        if (sectionId === "project") {
          // Merge "Unsold" and "Sold" headers
          merges.push({ s: { r: 0, c: 1 }, e: { r: 0, c: 10 } }); // Unsold
          merges.push({ s: { r: 0, c: 11 }, e: { r: 0, c: 20 } }); // Sold
        } else if (sectionId === "inv") {
          // Merge status group headers
          merges.push({ s: { r: 0, c: 1 }, e: { r: 0, c: 3 } });   // Available
          merges.push({ s: { r: 0, c: 4 }, e: { r: 0, c: 6 } });   // Unreleased
          merges.push({ s: { r: 0, c: 7 }, e: { r: 0, c: 9 } });   // Blocked Development
          merges.push({ s: { r: 0, c: 10 }, e: { r: 0, c: 12 } }); // Contracted
          merges.push({ s: { r: 0, c: 13 }, e: { r: 0, c: 15 } });   // Reserved
          merges.push({ s: { r: 0, c: 16 }, e: { r: 0, c: 18 } });   // Hold
          merges.push({ s: { r: 0, c: 19 }, e: { r: 0, c: 21 } });   // Partner
          merges.push({ s: { r: 0, c: 21 }, e: { r: 0, c: 24 } });   // Blocked Sales
          merges.push({ s: { r: 0, c: 24 }, e: { r: 0, c: 27 } });   // Blocked Cancellation
        }
        // Normalize all rows to same length
        ws_data.forEach(row => {
          while (row.length < maxCols) row.push({ v: "", t: "s", s: styles.dataCell });
        });
        // Create worksheet
        const ws = XLSX.utils.aoa_to_sheet(ws_data);
        ws["!merges"] = merges;
        // Set column widths
        const colWidths = [];
        ws_data.forEach(row => {
          row.forEach((cell, colIndex) => {
            const length = cell.v ? cell.v.toString().length : 0;
            if (!colWidths[colIndex] || length > colWidths[colIndex]) {
              colWidths[colIndex] = Math.min(Math.max(length, 8), 30);
            }
          });
        });
        ws["!cols"] = colWidths.map(w => ({ width: w + 2 }));
        // Freeze headers
        ws["!freeze"] = { xSplit: 1, ySplit: 2, topLeftCell: "C3", activePane: "bottomRight" };
        // Add filters
        if (ws_data.length > 1) {
          ws["!autofilter"] = { 
            ref: XLSX.utils.encode_range({
              s: { r: 1, c: 0 }, 
              e: { r: 1, c: maxCols - 1 }
            })
          };
        }
        XLSX.utils.book_append_sheet(wb, ws, "Pivot Data");
        // Generate filename
        let companyName = "Company";
        const label = document.querySelector(".controls span");
        if (label) {
          const raw = label.textContent || "";
          const match = raw.match(/Company:\s*(.*)/);
          if (match) companyName = match[1].trim().replace(/\s+/g, "_");
        }
        const now = new Date();
        const timestamp = now.toISOString().slice(0, 19).replace(/[-:T]/g, "");
        const fileName = `${companyName}_${sectionId}_${timestamp}.xlsx`;
        XLSX.writeFile(wb, fileName);
      }
      let currentUnits = [];
      window._expandedYears = new Set();
      function formatNumber(num) {
        const value = parseFloat(num);
        if (isNaN(value) || value === 0) return "-";
        return Math.round(value).toLocaleString();
      }
      function showSection(sectionId) {
        document.querySelectorAll(".section").forEach((sec) => sec.classList.remove("active-section"));
        document.getElementById(`${sectionId}Section`).classList.add("active-section");
        document.querySelectorAll(".buttons button").forEach(btn => {
          btn.classList.remove("active");
          if (btn.getAttribute("data-section") === sectionId) {
            btn.classList.add("active");
          }
        });
        // Show/hide year controls based on selected section
        const yearControls = document.getElementById("yearControls");
        yearControls.style.display = (sectionId === "sales" || sectionId === "delivery") ? "block" : "none";
        downloadControl.style.display = (sectionId === "project" || sectionId === "inv" || sectionId === "sales" || sectionId === "delivery") ? "block" : "none";
        if (sectionId === "project") buildPivotTable();
        if (sectionId === "inv") buildStatusPivotTable();
        if (sectionId === "sales") buildSalesPivotTable();
        if (sectionId === "delivery") buildDeliveryPivotTable();
      }
      function loadCompanyUnits() {
        const companyId = document.getElementById("companySelect").value;
        const buttons = document.querySelector(".buttons");
        if (!companyId) {
            clearSections();
            buttons.style.display = "none";
            return;
        }
        buttons.style.display = "flex";
        const url = `{% url 'get_company_units' %}?company_id=${companyId}`;
        fetch(url)
            .then((res) => res.json())
            .then((data) => {
                currentUnits = data.units || [];
                

                
                // Log summary of sales values
                const totalSalesValue = currentUnits.reduce((sum, unit) => sum + (parseFloat(unit.sales_value) || 0), 0);
                const avgSalesValue = currentUnits.length > 0 ? totalSalesValue / currentUnits.length : 0;
                

                
                showSection("home");
            });
      }
      function clearSections() {
        document.querySelectorAll(".section").forEach((sec) => sec.classList.remove("active-section"));
        document.getElementById("homeSection").classList.add("active-section");
        document.getElementById("homeSection").innerHTML =
          "<h2>Welcome</h2><p>Select a company from the dropdown above.</p>";
        document.getElementById("pivotTableContainer").innerHTML = "";
        document.getElementById("invPivotTableContainer").innerHTML = "";
        document.getElementById("salesPivotTableContainer").innerHTML = "";
        document.getElementById("deliveryPivotTableContainer").innerHTML = "";
      }
      function buildPivotTable() {
        if (!currentUnits.length) {
          document.getElementById("pivotTableContainer").innerHTML =
            "<p>No data available for this company.</p>";
          return;
        }
        // Group units into hierarchical structure
        const tree = {};
        currentUnits.forEach((unit) => {
          const city = unit.city || "Unknown";
          const project = unit.project || "Unknown";
          const type = unit.unit_type || "Unknown";
          const range = unit.area_range || "Unknown";
          const groupLevels = [city, project, type, range];
          let node = tree;
          for (let i = 0; i < groupLevels.length; i++) {
            const key = groupLevels[i];
            if (!node[key]) node[key] = { _agg: {}, _children: {} };
            node = node[key]._children;
          }
          if (!node._units) node._units = [];
          node._units.push(unit);
        });
        // Recursively build rows
        let rowIndex = 0;
        const rows = [];
        function aggregate(units) {
          const sold = { count: 0, area: 0, sales: 0, psm: [], price: [] };
          const unsold = { count: 0, area: 0, sales: 0, psm: [], price: [] };
          units.forEach((u) => {
            const target = u.adj_status === "Sold" ? sold : unsold;
            target.count++;
            target.area += parseFloat(u.gross_area) || 0;
            target.sales += parseFloat(u.sales_value) || 0;
            if (u.psm) target.psm.push(parseFloat(u.psm));
            if (u.interest_free_unit_price)
              target.price.push(parseFloat(u.interest_free_unit_price));
          });
          const total = sold.count + unsold.count;
          const getStats = (list) => {
            const filtered = list.filter((v) => !isNaN(v));
            const sum = filtered.reduce((a, b) => a + b, 0);
            const avg = filtered.length ? sum / filtered.length : 0;
            const min = filtered.length ? Math.min(...filtered) : 0;
            const max = filtered.length ? Math.max(...filtered) : 0;
            return { min, avg, max };
          };
          return {
            soldPercent: total ? ((sold.count / total) * 100).toFixed(2) : "0",
            unsoldPercent: total ? ((unsold.count / total) * 100).toFixed(2) : "0",
            sold: {
              ...sold,
              psmStats: getStats(sold.psm),
              priceStats: getStats(sold.price),
            },
            unsold: {
              ...unsold,
              psmStats: getStats(unsold.psm),
              priceStats: getStats(unsold.price),
            },
          };
        }
        function traverse(node, level = 0, parentId = null, label = "", path = []) {
          Object.entries(node).forEach(([key, value]) => {
            if (key === "_units") return;
            const id = `row-${++rowIndex}`;
            const fullPath = [...path, key];
            let units = [];
            function collectUnits(n) {
              let collected = [];
              if (n._units) collected = collected.concat(n._units);
              Object.values(n).forEach((child) => {
                if (child && child._children)
                  collected = collected.concat(collectUnits(child._children));
              });
              return collected;
            }
            units = collectUnits(value._children);
            const agg = aggregate(units);
            rows.push({
              id,
              parentId,
              level,
              label: key,
              path: fullPath,
              agg,
            });
            traverse(value._children, level + 1, id, key, fullPath);
          });
          if (node._units) {
            const id = `row-${++rowIndex}`;
            const agg = aggregate(node._units);
            rows.push({
              id,
              parentId,
              level,
              label: path[path.length - 1],
              path,
              agg,
            });
          }
        }
        traverse(tree);
        // Generate HTML
        const header = `
          <table>
            <thead>
              <tr>
                <th style="text-align: left; min-width: 250px;">Group</th>
                <th colspan="10" style="background:blue; color:white;">Unsold</th>
                <th colspan="10" style="background:grey; color:white;">Sold</th>
              </tr>
              <tr>
                <th></th>
                <th>%</th><th>No. of Units</th><th>Gross Area</th><th>Sales Value</th><th>Min PSM</th><th>Avg PSM</th><th>Max PSM</th><th>Min Unit Price</th><th>Avg Unit Price</th><th>Max Unit Price</th>
                <th>%</th><th>No. of Units</th><th>Gross Area</th><th>Sales Value</th><th>Min PSM</th><th>Avg PSM</th><th>Max PSM</th><th>Min Unit Price</th><th>Avg Unit Price</th><th>Max Unit Price</th>
              </tr>
            </thead>
            <tbody>
        `;
        let body = "";
        rows.forEach((row) => {
          const hasChildren = rows.some((r) => r.parentId === row.id);
          const icon = hasChildren
            ? `<span class="toggle" data-id="${row.id}" style="margin-right:6px;"></span>`
            : "";
          const indent = row.level * 30;
          const label = `
            <div class="group-label" style="padding-left: ${indent}px;">
                ${icon}<strong>${row.label}</strong>
            </div>
          `;
          const isHidden = row.level > 0 ? "hidden" : "";
          const s = row.agg.sold;
          const u = row.agg.unsold;
          const sPsm = s.psmStats;
          const uPsm = u.psmStats;
          const sPrice = s.priceStats;
          const uPrice = u.priceStats;
          body += `
            <tr class="${isHidden}" data-id="${row.id}" data-parent="${row.parentId || ""}">
              <td>${label}</td>
              <td>${formatNumber(row.agg.unsoldPercent)}%</td>
              <td>${formatNumber(u.count)}</td>
              <td>${formatNumber(u.area)}</td>
              <td>${formatNumber(u.sales)}</td>
              <td class="left-border">${formatNumber(uPsm.min)}</td>
              <td>${formatNumber(uPsm.avg)}</td>
              <td>${formatNumber(uPsm.max)}</td>
              <td class="left-border">${formatNumber(uPrice.min)}</td>
              <td>${formatNumber(uPrice.avg)}</td>
              <td>${formatNumber(uPrice.max)}</td>
              <td class="left-border">${formatNumber(row.agg.soldPercent)}%</td>
              <td>${formatNumber(s.count)}</td>
              <td>${formatNumber(s.area)}</td>
              <td>${formatNumber(s.sales)}</td>
              <td class="left-border">${formatNumber(sPsm.min)}</td>
              <td>${formatNumber(sPsm.avg)}</td>
              <td>${formatNumber(sPsm.max)}</td>
              <td class="left-border">${formatNumber(sPrice.min)}</td>
              <td>${formatNumber(sPrice.avg)}</td>
              <td>${formatNumber(sPrice.max)}</td>
            </tr>
          `;
        });
        const footer = `</tbody></table>`;
        document.getElementById("pivotTableContainer").innerHTML = header + body + footer;
        // Toggle functionality
        setupToggleFunctionality();
      }
      function buildStatusPivotTable() {
        if (!currentUnits.length) {
          document.getElementById("invPivotTableContainer").innerHTML =
            "<p>No data available for this company.</p>";
          return;
        }
        // Group units into hierarchical structure
        const tree = {};
        currentUnits.forEach((unit) => {
          const city = unit.city || "Unknown";
          const project = unit.project || "Unknown";
          const type = unit.unit_type || "Unknown";
          const groupLevels = [city, project, type];
          let node = tree;
          for (let i = 0; i < groupLevels.length; i++) {
            const key = groupLevels[i];
            if (!node[key]) node[key] = { _agg: {}, _children: {} };
            node = node[key]._children;
          }
          if (!node._units) node._units = [];
          node._units.push(unit);
        });
        // Recursively build rows
        let rowIndex = 0;
        const rows = [];
        function aggregate(units) {
          const statusGroups = {
            "Available": { count: 0, sales: 0 },
            "Unreleased": { count: 0, sales: 0 },
            "Blocked Development": { count: 0, sales: 0 },
            "Blocked Sales": { count: 0, sales: 0 },
            "Blocked Cancellation": { count: 0, sales: 0 },
            "Reserved": { count: 0, sales: 0 },
            "Contracted": { count: 0, sales: 0 },
            "Partner": { count: 0, sales: 0 },
            "Hold": { count: 0, sales: 0 }
          };
          units.forEach((u) => {
            const status = u.status || "Unknown";
            if (statusGroups[status]) {
              statusGroups[status].count++;
              statusGroups[status].sales += parseFloat(u.sales_value) || 0;
            }
          });
          const total = Object.values(statusGroups).reduce((sum, group) => sum + group.count, 0);
          return {
            statusGroups,
            total,
            percentages: {
              Available: total ? ((statusGroups["Available"].count / total) * 100).toFixed(2) : "0",
              Unreleased: total ? ((statusGroups["Unreleased"].count / total) * 100).toFixed(2) : "0",
              BlockedDevelopment: total ? ((statusGroups["Blocked Development"].count / total) * 100).toFixed(2) : "0",
              BlockedSales: total ? ((statusGroups["Blocked Sales"].count / total) * 100).toFixed(2) : "0",
              BlockedCancellation: total ? ((statusGroups["Blocked Cancellation"].count / total) * 100).toFixed(2) : "0",
              Reserved: total ? ((statusGroups["Reserved"].count / total) * 100).toFixed(2) : "0",
              Contracted: total ? ((statusGroups["Contracted"].count / total) * 100).toFixed(2) : "0",
              Hold: total ? ((statusGroups["Hold"].count / total) * 100).toFixed(2) : "0",
              Partner: total ? ((statusGroups["Partner"].count / total) * 100).toFixed(2) : "0"
            }
          };
        }
        function traverse(node, level = 0, parentId = null, label = "", path = []) {
          Object.entries(node).forEach(([key, value]) => {
            if (key === "_units") return;
            const id = `row-${++rowIndex}`;
            const fullPath = [...path, key];
            let units = [];
            function collectUnits(n) {
              let collected = [];
              if (n._units) collected = collected.concat(n._units);
              Object.values(n).forEach((child) => {
                if (child && child._children)
                  collected = collected.concat(collectUnits(child._children));
              });
              return collected;
            }
            units = collectUnits(value._children);
            const agg = aggregate(units);
            rows.push({
              id,
              parentId,
              level,
              label: key,
              path: fullPath,
              agg,
            });
            traverse(value._children, level + 1, id, key, fullPath);
          });
          if (node._units) {
            const id = `row-${++rowIndex}`;
            const agg = aggregate(node._units);
            rows.push({
              id,
              parentId,
              level,
              label: path[path.length - 1],
              path,
              agg,
            });
          }
        }
        traverse(tree);
        // Generate HTML
        const header = `
          <table>
            <thead>
              <tr>
                <th style="text-align: left; min-width: 250px;">Group</th>
                <th colspan="3" style="background:blue; color:white;">Available</th>
                <th colspan="3" style="background:blue; color:white;">Unreleased</th>
                <th colspan="3" style="background:blue; color:white;">Blocked Development</th>
                <th colspan="3" style="background:blue; color:white;">Blocked Sales</th>
                <th colspan="3" style="background:blue; color:white;">Blocked Cancellation</th>
                <th colspan="3" style="background:blue; color:white;">Partner</th>
                <th colspan="3" style="background:blue; color:white;">Hold</th>
                <th colspan="3" style="background:blue; color:white;">Reserved</th>
                <th colspan="3" style="background:grey; color:white;">Contracted</th>
              </tr>
              <tr>
                <th></th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
                <th>%</th><th>No. of Units</th><th>Sales Value</th>
              </tr>
            </thead>
            <tbody>
        `;
        let body = "";
        rows.forEach((row) => {
          const hasChildren = rows.some((r) => r.parentId === row.id);
          const icon = hasChildren
            ? `<span class="toggle" data-id="${row.id}" style="margin-right:6px;"></span>`
            : "";
          const indent = row.level * 30;
          const label = `
            <div class="group-label" style="padding-left: ${indent}px;">
                ${icon}<strong>${row.label}</strong>
            </div>
          `;
          const isHidden = row.level > 0 ? "hidden" : "";
          const s = row.agg.statusGroups;
          const p = row.agg.percentages;
          body += `
            <tr class="${isHidden}" data-id="${row.id}" data-parent="${row.parentId || ""}">
              <td>${label}</td>
              <!-- Available -->
              <td>${formatNumber(p.Available)}%</td>
              <td>${formatNumber(s["Available"].count)}</td>
              <td>${formatNumber(s["Available"].sales)}</td>
              <!-- Unreleased -->
              <td class="left-border">${formatNumber(p.Unreleased)}%</td>
              <td>${formatNumber(s["Unreleased"].count)}</td>
              <td>${formatNumber(s["Unreleased"].sales)}</td>
              <!-- Blocked Development -->
              <td class="left-border">${formatNumber(p.BlockedDevelopment)}%</td>
              <td>${formatNumber(s["Blocked Development"].count)}</td>
              <td>${formatNumber(s["Blocked Development"].sales)}</td>
               <!-- Blocked Sales -->
              <td class="left-border">${formatNumber(p.BlockedSales)}%</td>
              <td>${formatNumber(s["Blocked Sales"].count)}</td>
              <td>${formatNumber(s["Blocked Sales"].sales)}</td>
              <!-- Blocked Cancellation -->
              <td class="left-border">${formatNumber(p.BlockedCancellation)}%</td>
              <td>${formatNumber(s["Blocked Cancellation"].count)}</td>
              <td>${formatNumber(s["Blocked Cancellation"].sales)}</td>
              <!-- Partner -->
              <td class="left-border">${formatNumber(p.Partner)}%</td>
              <td>${formatNumber(s["Partner"].count)}</td>
              <td>${formatNumber(s["Partner"].sales)}</td>
              <!-- Hold -->
              <td class="left-border">${formatNumber(p.Hold)}%</td>
              <td>${formatNumber(s["Hold"].count)}</td>
              <td>${formatNumber(s["Hold"].sales)}</td>
              <!-- Reserved -->
              <td class="left-border">${formatNumber(p.Reserved)}%</td>
              <td>${formatNumber(s["Reserved"].count)}</td>
              <td>${formatNumber(s["Reserved"].sales)}</td>
              <!-- Contracted -->
              <td class="left-border">${formatNumber(p.Contracted)}%</td>
              <td>${formatNumber(s["Contracted"].count)}</td>
              <td>${formatNumber(s["Contracted"].sales)}</td>
            </tr>
          `;
        });
        const footer = `</tbody></table>`;
        document.getElementById("invPivotTableContainer").innerHTML = header + body + footer;
        // Toggle functionality
        setupToggleFunctionality();
      }
      function buildSalesPivotTable() {
        if (!currentUnits.length) {
            document.getElementById("salesPivotTableContainer").innerHTML =
                "<p>No data available for this company.</p>";
            return;
        }
        const contractedUnits = currentUnits.filter(unit => unit.status === "Contracted");
        if (!contractedUnits.length) {
            document.getElementById("salesPivotTableContainer").innerHTML =
                "<p>No contracted units found for this company.</p>";
            return;
        }
        const currentYear = new Date().getFullYear();
        const startYear = 2020;
        const tree = {};
        contractedUnits.forEach((unit) => {
            const city = unit.city || "Unknown";
            const project = unit.project || "Unknown";
            const type = unit.unit_type || "Unknown";
            const groupLevels = [city, project, type];
            let node = tree;
            for (let i = 0; i < groupLevels.length; i++) {
                const key = groupLevels[i];
                if (!node[key]) node[key] = { _agg: {}, _children: {} };
                node = node[key]._children;
            }
            if (!node._units) node._units = [];
            node._units.push(unit);
        });
        let rowIndex = 0;
        const rows = [];
        function aggregate(units) {
            const yearGroups = {};
            for (let year = startYear; year <= currentYear; year++) {
                yearGroups[year] = {
                    count: 0, sales: 0,
                    months: Array(12).fill(null).map(() => ({ count: 0, sales: 0 }))
                };
            }
            units.forEach((u) => {
                if (u.reservation_date) {
                    const date = new Date(u.reservation_date);
                    if (!isNaN(date)) {
                        const year = date.getFullYear();
                        const month = date.getMonth();
                        if (yearGroups[year]) {
                            yearGroups[year].count++;
                            yearGroups[year].sales += parseFloat(u.sales_value) || 0;
                            yearGroups[year].months[month].count++;
                            yearGroups[year].months[month].sales += parseFloat(u.sales_value) || 0;
                        }
                    }
                }
            });
            const total = Object.values(yearGroups).reduce((sum, group) => sum + group.count, 0);
            const percentages = {};
            for (const year in yearGroups) {
                percentages[year] = total ? ((yearGroups[year].count / total) * 100).toFixed(2) : "0";
            }
            return {
                yearGroups,
                total,
                percentages
            };
        }
        function traverse(node, level = 0, parentId = null, label = "", path = []) {
            Object.entries(node).forEach(([key, value]) => {
                if (key === "_units") return;
                const id = `row-${++rowIndex}`;
                const fullPath = [...path, key];
                let units = [];
                function collectUnits(n) {
                    let collected = [];
                    if (n._units) collected = collected.concat(n._units);
                    Object.values(n).forEach((child) => {
                        if (child && child._children)
                            collected = collected.concat(collectUnits(child._children));
                    });
                    return collected;
                }
                units = collectUnits(value._children);
                const agg = aggregate(units);
                rows.push({
                    id,
                    parentId,
                    level,
                    label: key,
                    path: fullPath,
                    agg,
                });
                traverse(value._children, level + 1, id, key, fullPath);
            });
            if (node._units) {
                const id = `row-${++rowIndex}`;
                const agg = aggregate(node._units);
                rows.push({
                    id,
                    parentId,
                    level,
                    label: path[path.length - 1],
                    path,
                    agg,
                });
            }
        }
        traverse(tree);
        // Initial Render
        renderSalesPivotTable(rows);
        // Setup toggles
        setupToggleFunctionality();
      }
      function buildDeliveryPivotTable() {
        if (!currentUnits.length) {
            document.getElementById("deliveryPivotTableContainer").innerHTML =
                "<p>No data available for this company.</p>";
            return;
        }
        // Get min and max years from development_delivery_date
        let minYear = Infinity;
        let maxYear = -Infinity;
        currentUnits.forEach(unit => {
            if (unit.development_delivery_date) {
                const date = new Date(unit.development_delivery_date);
                if (!isNaN(date)) {
                    const year = date.getFullYear();
                    if (year < minYear) minYear = year;
                    if (year > maxYear) maxYear = year;
                }
            }
        });
        // Default to current year if no valid dates found
        if (minYear === Infinity) {
            minYear = new Date().getFullYear();
            maxYear = minYear;
        }
        // Start from 2024 or the min year, whichever is later
        const startYear = Math.max(2024, minYear);
        const tree = {};
        currentUnits.forEach((unit) => {
            const city = unit.city || "Unknown";
            const project = unit.project || "Unknown";
            const type = unit.unit_type || "Unknown";
            const groupLevels = [city, project, type];
            let node = tree;
            for (let i = 0; i < groupLevels.length; i++) {
                const key = groupLevels[i];
                if (!node[key]) node[key] = { _agg: {}, _children: {} };
                node = node[key]._children;
            }
            if (!node._units) node._units = [];
            node._units.push(unit);
        });
        let rowIndex = 0;
        const rows = [];
        function aggregate(units) {
            const yearGroups = {};
            for (let year = startYear; year <= maxYear; year++) {
                yearGroups[year] = {
                    count: 0, sales: 0,
                    months: Array(12).fill(null).map(() => ({ count: 0, sales: 0 }))
                };
            }
            units.forEach((u) => {
                if (u.development_delivery_date) {
                    const date = new Date(u.development_delivery_date);
                    if (!isNaN(date)) {
                        const year = date.getFullYear();
                        const month = date.getMonth();
                        if (yearGroups[year]) {
                            yearGroups[year].count++;
                            yearGroups[year].sales += parseFloat(u.sales_value) || 0;
                            yearGroups[year].months[month].count++;
                            yearGroups[year].months[month].sales += parseFloat(u.sales_value) || 0;
                        }
                    }
                }
            });
            const total = Object.values(yearGroups).reduce((sum, group) => sum + group.count, 0);
            const percentages = {};
            for (const year in yearGroups) {
                percentages[year] = total ? ((yearGroups[year].count / total) * 100).toFixed(2) : "0";
            }
            return {
                yearGroups,
                total,
                percentages
            };
        }
        function traverse(node, level = 0, parentId = null, label = "", path = []) {
            Object.entries(node).forEach(([key, value]) => {
                if (key === "_units") return;
                const id = `row-${++rowIndex}`;
                const fullPath = [...path, key];
                let units = [];
                function collectUnits(n) {
                    let collected = [];
                    if (n._units) collected = collected.concat(n._units);
                    Object.values(n).forEach((child) => {
                        if (child && child._children)
                            collected = collected.concat(collectUnits(child._children));
                    });
                    return collected;
                }
                units = collectUnits(value._children);
                const agg = aggregate(units);
                rows.push({
                    id,
                    parentId,
                    level,
                    label: key,
                    path: fullPath,
                    agg,
                });
                traverse(value._children, level + 1, id, key, fullPath);
            });
            if (node._units) {
                const id = `row-${++rowIndex}`;
                const agg = aggregate(node._units);
                rows.push({
                    id,
                    parentId,
                    level,
                    label: path[path.length - 1],
                    path,
                    agg,
                });
            }
        }
        traverse(tree);
        // Initial Render
        renderDeliveryPivotTable(rows, startYear, maxYear);
        // Setup toggles
        setupToggleFunctionality();
      }
      function collapseAllYears() {
        window._expandedYears = new Set(); // Clear all expanded years
        if (document.getElementById("salesSection").classList.contains("active-section")) {
            buildSalesPivotTable(); // Rebuild the sales table with all years collapsed
        } else if (document.getElementById("deliverySection").classList.contains("active-section")) {
            buildDeliveryPivotTable(); // Rebuild the delivery table with all years collapsed
        }
      }
      function expandAllYears() {
        const currentYear = new Date().getFullYear();
        window._expandedYears = new Set();
        if (document.getElementById("salesSection").classList.contains("active-section")) {
            const startYear = 2020;
            for (let year = startYear; year <= currentYear; year++) {
                window._expandedYears.add(year);
            }
            buildSalesPivotTable(); // Rebuild the sales table with all years expanded
        } else if (document.getElementById("deliverySection").classList.contains("active-section")) {
            // For delivery, we need to determine the years dynamically
            let minYear = Infinity;
            let maxYear = -Infinity;
            currentUnits.forEach(unit => {
                if (unit.development_delivery_date) {
                    const date = new Date(unit.development_delivery_date);
                    if (!isNaN(date)) {
                        const year = date.getFullYear();
                        if (year < minYear) minYear = year;
                        if (year > maxYear) maxYear = year;
                    }
                }
            });
            // Default to current year if no valid dates found
            if (minYear === Infinity) {
                minYear = new Date().getFullYear();
                maxYear = minYear;
            }
            // Start from 2024 or the min year, whichever is later
            const startYear = Math.max(2024, minYear);
            for (let year = startYear; year <= maxYear; year++) {
                window._expandedYears.add(year);
            }
            buildDeliveryPivotTable(); // Rebuild the delivery table with all years expanded
        }
      }
      function formatNumber(value) {
        return Number(value || 0).toLocaleString(undefined, { maximumFractionDigits: 2 });
      }


      function renderSalesPivotTable(rows) {
        const currentYear = new Date().getFullYear();
        const startYear = 2020;
        // Determine which months to show (i.e., months with any units)
        const visibleMonthsByYear = {};
        for (let year = startYear; year <= currentYear; year++) {
            visibleMonthsByYear[year] = Array(12).fill(false);
            rows.forEach(row => {
                const group = row.agg.yearGroups[year];
                if (group && group.months) {
                    group.months.forEach((month, idx) => {
                        if (month.count > 0) visibleMonthsByYear[year][idx] = true;
                    });
                }
            });
        }
        let headerYears = '';
        let headerCols = '';
        for (let year = startYear; year <= currentYear; year++) {
            if (window._expandedYears.has(year)) {
                for (let m = 0; m < 12; m++) {
                    if (!visibleMonthsByYear[year][m]) continue;
                    const monthName = new Date(year, m, 1).toLocaleString('default', { month: 'short' });
                    const monthClass = m > 0 ? 'month-group' : '';
                    headerYears += `<th colspan="3" style="background:#555; color:white;" class="${monthClass}">${monthName} ${year}</th>`;
                    headerCols += '<th>%</th><th>No. of Units</th><th>Sales Value</th>';
                }
            } else {
                const arrow = "";
                headerYears += `<th colspan="3" style="background:grey; color:white;" class="year-group">
                    <button class="year-toggle" data-year="${year}" style="color:white; background:none; border:none; cursor:pointer;">
                        ${year} ${arrow}
                    </button>
                </th>`;
                headerCols += '<th>%</th><th>No. of Units</th><th>Sales Value</th>';
            }
        }
        const header = `
            <table>
                <thead>
                    <tr>
                        <th style="text-align: left; min-width: 250px;">Group</th>
                        ${headerYears}
                    </tr>
                    <tr>
                        <th></th>
                        ${headerCols}
                    </tr>
                </thead>
                <tbody>
        `;
        let body = "";
        rows.forEach((row) => {
            const hasChildren = rows.some((r) => r.parentId === row.id);
            const icon = hasChildren ? `<span class="toggle" data-id="${row.id}" style="margin-right:6px;"></span>` : "";
            const indent = row.level * 30;
            const label = `<div class="group-label" style="padding-left: ${indent}px;">${icon}<strong>${row.label}</strong></div>`;
            const isHidden = row.level > 0 ? "hidden" : "";
            const y = row.agg.yearGroups;
            const p = row.agg.percentages;
            let rowContent = `<tr class="${isHidden}" data-id="${row.id}" data-parent="${row.parentId || ""}"><td>${label}</td>`;
            for (let year = startYear; year <= currentYear; year++) {
                if (window._expandedYears.has(year)) {
                    for (let m = 0; m < 12; m++) {
                        if (!visibleMonthsByYear[year][m]) continue;
                        const monthTotal = y[year].months[m];
                        const totalYearCount = y[year].count || 1;
                        const percent = ((monthTotal.count / totalYearCount) * 100).toFixed(2);
                        const monthClass = m > 0 ? 'month-group' : '';
                        rowContent += `
                            <td class="${monthClass}">${formatNumber(percent)}%</td>
                            <td class="${monthClass}">${formatNumber(monthTotal.count)}</td>
                            <td class="${monthClass}">${formatNumber(monthTotal.sales)}</td>
                        `;
                    }
                } else {
                    rowContent += `
                        <td class="year-group">${formatNumber(p[year])}%</td>
                        <td class="year-group">${formatNumber(y[year].count)}</td>
                        <td class="year-group">${formatNumber(y[year].sales)}</td>
                    `;
                }
            }
            rowContent += `</tr>`;
            body += rowContent;
        });
        const footer = `</tbody></table>`;
        document.getElementById("salesPivotTableContainer").innerHTML = header + body + footer;
      }
      function renderDeliveryPivotTable(rows, startYear, maxYear) {
        // Determine which months to show
        const visibleMonthsByYear = {};
        for (let year = startYear; year <= maxYear; year++) {
            visibleMonthsByYear[year] = Array(12).fill(false);
            rows.forEach(row => {
                const group = row.agg.yearGroups[year];
                if (group && group.months) {
                    group.months.forEach((month, idx) => {
                        if (month.count > 0) visibleMonthsByYear[year][idx] = true;
                    });
                }
            });
        }
        let headerYears = '';
        let headerCols = '';
        for (let year = startYear; year <= maxYear; year++) {
            if (window._expandedYears.has(year)) {
                for (let m = 0; m < 12; m++) {
                    if (!visibleMonthsByYear[year][m]) continue;
                    const monthName = new Date(year, m, 1).toLocaleString('default', { month: 'short' });
                    const monthClass = m > 0 ? 'month-group' : '';
                    headerYears += `<th colspan="3" style="background:blue; color:white;" class="${monthClass}">${monthName} ${year}</th>`;
                    headerCols += '<th>%</th><th>No. of Units</th><th>Sales Value</th>';
                }
            } else {
                const arrow = "";
                headerYears += `<th colspan="3" style="background:blue; color:white;" class="year-group">
                    <button class="year-toggle" data-year="${year}" style="color:white; background:none; border:none; cursor:pointer;">
                        ${year} ${arrow}
                    </button>
                </th>`;
                headerCols += '<th>%</th><th>No. of Units</th><th>Sales Value</th>';
            }
        }
        const header = `
            <table>
                <thead>
                    <tr>
                        <th style="text-align: left; min-width: 250px;">Group</th>
                        ${headerYears}
                    </tr>
                    <tr>
                        <th></th>
                        ${headerCols}
                    </tr>
                </thead>
                <tbody>
        `;
        let body = "";
        rows.forEach((row) => {
            const hasChildren = rows.some((r) => r.parentId === row.id);
            const icon = hasChildren ? `<span class="toggle" data-id="${row.id}" style="margin-right:6px;"></span>` : "";
            const indent = row.level * 30;
            const label = `<div class="group-label" style="padding-left: ${indent}px;">${icon}<strong>${row.label}</strong></div>`;
            const isHidden = row.level > 0 ? "hidden" : "";
            const y = row.agg.yearGroups;
            const p = row.agg.percentages;
            let rowContent = `<tr class="${isHidden}" data-id="${row.id}" data-parent="${row.parentId || ""}"><td>${label}</td>`;
            for (let year = startYear; year <= maxYear; year++) {
                if (window._expandedYears.has(year)) {
                    for (let m = 0; m < 12; m++) {
                        if (!visibleMonthsByYear[year][m]) continue;
                        const monthTotal = y[year].months[m];
                        const totalYearCount = y[year].count || 1;
                        const percent = ((monthTotal.count / totalYearCount) * 100).toFixed(2);
                        const monthClass = m > 0 ? 'month-group' : '';
                        rowContent += `
                            <td class="${monthClass}">${formatNumber(percent)}%</td>
                            <td class="${monthClass}">${formatNumber(monthTotal.count)}</td>
                            <td class="${monthClass}">${formatNumber(monthTotal.sales)}</td>
                        `;
                    }
                } else {
                    rowContent += `
                        <td class="year-group">${formatNumber(p[year])}%</td>
                        <td class="year-group">${formatNumber(y[year].count)}</td>
                        <td class="year-group">${formatNumber(y[year].sales)}</td>
                    `;
                }
            }
            rowContent += `</tr>`;
            body += rowContent;
        });
        const footer = `</tbody></table>`;
        document.getElementById("deliveryPivotTableContainer").innerHTML = header + body + footer;
      }
      function setupToggleFunctionality() {
        document.querySelectorAll(".toggle").forEach((el) =>
            el.addEventListener("click", function () {
                const id = this.getAttribute("data-id");
                const rows = document.querySelectorAll(`[data-parent="${id}"]`);
                const isExpanded = this.textContent === "";
                this.textContent = isExpanded ? "" : "";
                rows.forEach((row) => {
                    row.classList.toggle("hidden");
                    if (isExpanded) {
                        hideChildren(row.getAttribute("data-id"));
                    }
                });
            })
        );
        document.querySelectorAll(".year-toggle").forEach((btn) =>
            btn.addEventListener("click", function () {
                const year = parseInt(this.getAttribute("data-year"));
                if (window._expandedYears?.has(year)) {
                    window._expandedYears.delete(year);
                } else {
                    window._expandedYears = window._expandedYears || new Set();
                    window._expandedYears.add(year);
                }
                if (document.getElementById("salesSection").classList.contains("active-section")) {
                    buildSalesPivotTable();
                } else if (document.getElementById("deliverySection").classList.contains("active-section")) {
                    buildDeliveryPivotTable();
                }
            })
        );
      }
      function hideChildren(parentId) {
        const children = document.querySelectorAll(`[data-parent="${parentId}"]`);
        children.forEach((row) => {
            row.classList.add("hidden");
            hideChildren(row.getAttribute("data-id"));
        });
      }
      function toggleChildren(parentId, show) {
        const children = document.querySelectorAll(`[data-parent="${parentId}"]`);
        children.forEach((child) => {
          if (show) {
            child.classList.remove("hidden");
          } else {
            child.classList.add("hidden");
            const childId = child.getAttribute("data-id");
            toggleChildren(childId, false);
            const toggleEl = child.querySelector(".toggle");
            if (toggleEl) toggleEl.textContent = "";
          }
        });
      }
    </script>

    <script>
      window.addEventListener("DOMContentLoaded", () => {
        const companySelect = document.getElementById("companySelect");
        const selectedCompany = companySelect ? companySelect.value : "{{ selected_company_id }}";
        if (selectedCompany) {
          if (companySelect) {
            companySelect.value = selectedCompany;
          }
          const url = "{% url 'get_company_units' %}?company_id=" + selectedCompany;
          fetch(url)
            .then((res) => res.json())
            .then((data) => {
              currentUnits = data.units || [];
              /* document.getElementById("homeSection").innerHTML = `<h2>${
                data.units.length ? "Company Selected" : "No Units Found"
              }</h2>`;*/
              document.querySelector(".buttons").style.display = "flex";
              showSection("home");
            });
        }
      });
    </script>
    <script>
          const pieConnectorLines = {
            id: 'pieConnectorLines',
            afterDraw(chart) {
              const { ctx, data } = chart;
              if (chart.config.type !== 'pie') return;

              chart.getDatasetMeta(0).data.forEach((datapoint, index) => {
                  const { x, y, startAngle, endAngle, outerRadius } = datapoint;
                  const midAngle = startAngle + (endAngle - startAngle) / 2;
                  
                  // Calculate percentage
                  const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                  const value = data.datasets[0].data[index];
                  const percentage = (value / total) * 100;

                  // Only draw line if less than 10%
                  if (percentage < 5 && value > 0) {
                      const x1 = x + Math.cos(midAngle) * outerRadius;
                      const y1 = y + Math.sin(midAngle) * outerRadius;
                      const x2 = x + Math.cos(midAngle) * (outerRadius + 10);
                      const y2 = y + Math.sin(midAngle) * (outerRadius + 10);

                      ctx.save();
                      ctx.strokeStyle = datapoint.options.backgroundColor;
                      ctx.lineWidth = 2;
                      ctx.beginPath();
                      ctx.moveTo(x1, y1);
                      ctx.lineTo(x2, y2);
                      ctx.stroke();
                      ctx.restore();
                  }
              });
          }
      };

      // Register the plugin
      Chart.register(pieConnectorLines);
      class Dashboard {
        constructor() {
            this.currentCompany = null;

            this.filterConfig = {
                projects: { prop: 'project', id: 'projectFilter' },
                unitTypes: { prop: 'unit_type', id: 'unitTypeFilter' },
                contractPaymentPlans: { prop: 'contract_payment_plan', id: 'contractPaymentPlanFilter' },
                statuses: { prop: 'status', id: 'statusFilter' },
                areas: { prop: 'area_range', id: 'areaFilter' },
                cities: { prop: 'city', id: 'cityFilter' },
                owners: { prop: 'owner', id: 'ownerFilter' }
            };

            
            this.filters = {
                projects: [],
                unitTypes: [],
                contractPaymentPlans:[],
                statuses: [],
                areas: [],
                cities: [],
                owners: [],
                // Add date range filters
                salesDateRange: { start: null, end: null },
                deliveryDateRange: { start: null, end: null }
            };
            this.charts = {};
            this.units = [];
            this.init();
        }
        async init() {
            this.initEventListeners();
            // Check if there's a pre-selected company (for managers)
            const companySelect = document.getElementById("companySelect");
            const selectedCompanyId = companySelect ? companySelect.value : "{{ selected_company_id }}";
            if (selectedCompanyId) {
                await this.loadCompanyData(selectedCompanyId);
            }
            // Setup chart buttons
            this.setupChartButtons();
        }
        initEventListeners() {
            // Refresh button
            document.getElementById("refreshBtn")?.addEventListener("click", () => {
                if (this.currentCompany) {
                    this.loadCompanyData(this.currentCompany);
                }
            });
            // Export button
            document.getElementById("exportData")?.addEventListener("click", () => {
                this.exportData();
            });
            // Company select change
            document.getElementById("companySelect")?.addEventListener("change", (e) => {
                this.loadCompanyData(e.target.value);
            });
            // Filter checkboxes
            document.querySelectorAll('.filter-options input[type="checkbox"]').forEach(input => {
                input.addEventListener('change', () => this.updateFilters());
            });
        }

        setupChartButtons() {
            // Use delegation per chart-actions container
            document.querySelectorAll('.chart-actions').forEach(container => {
                container.addEventListener('click', (e) => {
                    const button = e.target.closest('.chart-btn');
                    if (!button) return;

                    // CRITICAL FIX: If the button already has an inline onclick (like Inventory/UnitModel),
                    // ignore this listener to prevent "Double Click" / double-open issues.
                    if (button.hasAttribute('onclick')) return;

                    e.preventDefault();

                    // Find the canvas associated with this button
                    // Strategy: Look in the immediate parent wrapper of the header first
                    const header = button.closest('.chart-header');
                    const parentWrapper = header ? header.parentElement : null;
                    let canvas = null;

                    if (parentWrapper) {
                        // Try to find a canvas in the same wrapper (Handles Delivery/Sales/Unit Metrics)
                        canvas = parentWrapper.querySelector('canvas');
                    }

                    if (!canvas) {
                        // Fallback for simple cards
                        const card = button.closest('.chart-card');
                        if (card) canvas = card.querySelector('canvas');
                    }

                    if (!canvas) {
                        console.warn("Could not find canvas associated with the clicked button.");
                        return;
                    }

                    // Route by icon
                    if (button.querySelector('.fa-expand')) {
                        this.expandChart(canvas);
                    } else if (button.querySelector('.fa-download')) {
                        this.downloadChart(canvas);
                    }
                });
            });
        }

        resetPeriodSelectors() {
            // 1. Reset Sales Period to Annually
            const salesBtns = document.querySelectorAll('.period-btn:not(#deliveryPeriodSelector .period-btn)');
            salesBtns.forEach(btn => {
                if (btn.dataset.period === 'annually') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            // Update global variable for sales period used by event listeners
            if (typeof currentSalesPeriod !== 'undefined') {
                currentSalesPeriod = 'annually'; 
            }

            // 2. Reset Delivery Period to Quarterly (or Annually if you prefer)
            // Keeping Quarterly as it was the original default in your code, 
            // but ensuring UI reflects it.
            const deliveryBtns = document.querySelectorAll('#deliveryPeriodSelector .period-btn');
            deliveryBtns.forEach(btn => {
                if (btn.dataset.period === 'annually') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        getEnhancedTooltipCallbacks(chartId) {
          const callbacks = {
            label: function(context) {
              const label = context.label || context.dataset.label || '';
              let value = typeof context.parsed === 'object' && context.parsed !== null
                ? context.parsed.y ?? context.parsed.x ?? JSON.stringify(context.parsed)
                : context.parsed;
              
              if (typeof value === 'number') {
                value = value.toLocaleString();
              }
              
              // ADD PERCENTAGE CALCULATION FOR BAR CHARTS
              if (context.chart.config.type === 'bar') {
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const percentage = total > 0 ? ((context.parsed.y / total) * 100).toFixed(2) : 0;
                return [
                  `${label}: ${value}`,
                  `Percentage: ${percentage}%`
                ];
              }
              
              return `${label}: ${value}`;
            }
          };
        
          // ... rest of your existing tooltip callbacks for doughnut charts
          // Special tooltip handling for doughnut charts
          if (chartId === 'inventoryChart' || chartId === 'unitModelChart' || chartId === 'contractPaymentPlanChart') {
            callbacks.beforeLabel = function(context) {
              if (context.chart.config.type === 'pie') {
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const percentage = ((context.parsed / total) * 100).toFixed(2);
                const label = context.label;
                
                let unitCount = 0;
                let salesValue = 0;
                let totalUnits = 0;
        
                if (context.chart.canvas.id === 'inventoryChart' || context.chart.canvas.id.includes('inventoryChart')) {
                  totalUnits = window.dashboard.units.length;
                  const statusCounts = window.dashboard.groupByStatus(window.dashboard.units);
                  unitCount = statusCounts[label] || 0;
                  salesValue = window.dashboard.units.filter(u => u.status === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                } else if (context.chart.canvas.id === 'unitModelChart' || context.chart.canvas.id.includes('unitModelChart')) {
                  totalUnits = window.dashboard.units.length;
                  const modelCounts = window.dashboard.groupByUnitType(window.dashboard.units);
                  unitCount = modelCounts[label] || 0;
                  salesValue = window.dashboard.units.filter(u => u.unit_model === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                } else if (context.chart.canvas.id === 'contractPaymentPlanChart' || context.chart.canvas.id.includes('contractPaymentPlanChart')) {
                  totalUnits = window.dashboard.units.length;
                  const planCounts = window.dashboard.groupByContractPaymentPlan(window.dashboard.units);
                  unitCount = planCounts[label] || 0;
                  salesValue = window.dashboard.units.filter(u => u.contract_payment_plan === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                }
        
                const percentOfTotal = totalUnits > 0 ? ((unitCount / totalUnits) * 100).toFixed(2) : 0;
        
                return [
                  `Number of Units: ${unitCount}`,
                  `Total Sales Value: ${window.dashboard.formatCurrency(salesValue)}`,
                  `% of Total Inventory: ${percentOfTotal}%`
                ];
              }
              return '';
            };
          }
        
          return callbacks;
        }


        downloadChart(canvas) {
            try {
                const link = document.createElement('a');
                const chartName = canvas.id.replace('Chart', '');
                link.download = `${chartName}_${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error downloading chart:', error);
                alert('Failed to download chart. Please try again.');
            }
        }

        expandChart(canvas) {
            try {
                const modal = document.createElement('div');
                modal.className = 'chart-modal';
                modal.style.cssText = `
                  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                  background-color: rgba(0,0,0,0.9); z-index: 2000;
                  display: flex; justify-content: center; align-items: center;
                  padding: 20px; box-sizing: border-box; overflow: auto;
                `;

                const container = document.createElement('div');
                container.className = 'chart-modal-container';
                container.style.cssText = `
                  position: relative; background: white; padding: 30px;
                  border-radius: 12px; max-width: 95vw; max-height: 95vh;
                  overflow: auto; display: flex; flex-direction: column;
                  align-items: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                  width: -webkit-fill-available; min-width: 300px;
                `;

                const originalChartInstance = canvas.chartInstance;
                const chartTitle = document.createElement('h3');
                chartTitle.textContent = this.getChartTitle(canvas.id);
                chartTitle.style.cssText = `margin: 0 0 20px 0; color: #333; font-size: 24px; font-weight: 600; text-align: center; width: 100%;`;
                container.appendChild(chartTitle);

                const isUnitMetricsChart = ['unitPriceChart', 'unitPSMChart', 'unitAreaChart'].includes(canvas.id);

                if (isUnitMetricsChart) {
                    const wrapperDiv = document.createElement('div');
                    wrapperDiv.className = 'unit-metrics-chart-wrapper';
                    wrapperDiv.style.cssText = `border: 1px solid #e9ecef; border-radius: 5px; background: #fafafa; height: 500px; width: 100%; position: relative; margin: 0 auto; overflow: hidden;`;

                    const canvasContainer = document.createElement('div');
                    canvasContainer.className = 'unit-metrics-chart-canvas-container';
                    canvasContainer.style.cssText = `width: 100%; height: calc(100% - 30px); overflow-x: auto; overflow-y: hidden; position: relative; -webkit-overflow-scrolling: touch;`;

                    const expandedCanvas = document.createElement('canvas');
                    expandedCanvas.id = `${canvas.id}-modal`;
                    expandedCanvas.className = 'unit-metrics-chart';
                    expandedCanvas.style.cssText = `width: 100% !important; height: 100% !important; min-width: 600px;`;

                    canvasContainer.appendChild(expandedCanvas);
                    wrapperDiv.appendChild(canvasContainer);
                    container.appendChild(wrapperDiv);

                    const currentUnits = this.getFilteredUnits();
                    let valueField;
                    switch (canvas.id) {
                        case 'unitPriceChart': valueField = 'interest_free_unit_price'; break;
                        case 'unitPSMChart': valueField = 'psm'; break;
                        case 'unitAreaChart': valueField = 'gross_area'; break;
                    }
                    
                    setTimeout(() => {
                        renderUnitMetricsChart(`${canvas.id}-modal`, currentUnits, valueField, chartTitle.textContent, '#D2691E', true);
                    }, 100);

                } else if (originalChartInstance) {
                    const expandedCanvas = document.createElement('canvas');
                    expandedCanvas.width = 600;
                    expandedCanvas.height = 500;
                    expandedCanvas.style.width = '100%';
                    expandedCanvas.style.height = '400px';
                    expandedCanvas.style.minHeight = '300px';
                    container.appendChild(expandedCanvas);

                    const currentUnits = this.getFilteredUnits();

                    setTimeout(() => {
                        const chartType = originalChartInstance.config.type;
                        const originalData = JSON.parse(JSON.stringify(originalChartInstance.data));
                        const isPie = chartType === 'pie' || chartType === 'pie';

                        const modalOptions = {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: isPie ? 'nearest' : 'index',
                                intersect: isPie ? true : false,
                                axis: isPie ? undefined : 'x'
                            },
                            plugins: {
                                legend: { position: 'bottom', labels: { boxWidth: 12, padding: 15, font: { size: 14 } } },
                                tooltip: {
                                    enabled: true,
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                    titleColor: '#fff',
                                    bodyColor: '#fff',
                                    borderColor: 'rgba(255, 255, 255, 0.2)',
                                    borderWidth: 1,
                                    cornerRadius: 4,
                                    displayColors: true,
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.label || context.dataset.label || '';
                                            let value = context.parsed.y !== undefined ? context.parsed.y : context.parsed;
                                            let formattedValue = value;
                                            if (typeof value === 'number') {
                                                if (canvas.id.includes('sales')) formattedValue = window.dashboard.formatCurrency(value);
                                                else formattedValue = value.toLocaleString();
                                            }
                                            if (chartType === 'line') return `${label}: ${formattedValue}`;
                                            
                                            // Calculate Stack Percentage (Relative to visible data)
                                            const total = context.dataset.data.reduce((a, b) => {
                                                const val = typeof a === 'number' ? a : (a.y || 0);
                                                const current = typeof b === 'number' ? b : (b.y || 0);
                                                return val + current;
                                            }, 0);
                                            const percentage = total > 0 ? (((typeof context.parsed === 'number' ? context.parsed : context.parsed.y) / total) * 100).toFixed(1) : 0;
                                            return `${label}: ${formattedValue} units (${percentage}%)`;
                                        },
                                        beforeLabel: function(context) {
                                            if (['inventoryChart', 'unitModelChart', 'contractPaymentPlanChart'].includes(canvas.id)) {
                                                if (context.chart.config.type === 'pie' || context.chart.config.type === 'bar') {
                                                    const label = context.label;
                                                    let unitCount = 0; 
                                                    let salesValue = 0; 
                                                    // Default to filtered total
                                                    let totalUnits = currentUnits.length; 

                                                    if (canvas.id === 'inventoryChart' || canvas.id.includes('inventoryChart')) {
                                                        // Inventory Chart compares to GLOBAL Total
                                                        totalUnits = window.dashboard.units.length; 
                                                        const statusCounts = window.dashboard.groupByStatus(currentUnits);
                                                        unitCount = statusCounts[label] || 0;
                                                        salesValue = currentUnits.filter(u => u.status === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                                                    } else if (canvas.id === 'unitModelChart' || canvas.id.includes('unitModelChart')) {
                                                        // Unit Model compares to GLOBAL Total
                                                        totalUnits = window.dashboard.units.length; 
                                                        const modelCounts = window.dashboard.groupByUnitType(currentUnits);
                                                        unitCount = modelCounts[label] || 0;
                                                        salesValue = currentUnits.filter(u => u.unit_type === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                                                    } else if (canvas.id === 'contractPaymentPlanChart' || canvas.id.includes('contractPaymentPlanChart')) {
                                                        // Contract Plan compares to FILTERED Total (what is currently visible)
                                                        totalUnits = currentUnits.length; 
                                                        const planCounts = window.dashboard.groupByContractPaymentPlan(currentUnits);
                                                        unitCount = planCounts[label] || 0;
                                                        salesValue = currentUnits.filter(u => u.contract_payment_plan === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                                                    }

                                                    if (unitCount === 0) return null;

                                                    // --- FIX APPLIED HERE ---
                                                    // Ensure we multiply by 100 before toFixed(2)
                                                    const percentOfTotal = totalUnits > 0 ? ((unitCount / totalUnits) * 100).toFixed(2) : 0;

                                                    return [
                                                        `Number of Units: ${unitCount}`,
                                                        `Total Sales Value: ${window.dashboard.formatCurrency(salesValue)}`,
                                                        `% of Total Inventory: ${percentOfTotal}%`
                                                    ];
                                                }
                                            }
                                            return null;
                                        }
                                    }
                                }
                            }
                        };

                        // --- SPECIFIC LOGIC FOR SALES TREND CHART ---
                        if (canvas.id === 'salesTrendChart') {
                            // 1. Enable DataLabels with "98.5M" formatting
                            modalOptions.plugins.datalabels = {
                                display: true,
                                align: 'top',
                                anchor: 'end',
                                offset: 5,
                                font: { weight: 'bold', size: 12 },
                                color: '#333',
                                formatter: function(value) {
                                    if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                                    if (value >= 1000) return (value / 1000).toFixed(0) + 'k';
                                    return value;
                                }
                            };

                            // 2. Custom Tooltip for Units Sold & Avg Value
                            modalOptions.plugins.tooltip.callbacks.label = function(context) {
                                const value = context.parsed.y;
                                const formattedSales = window.dashboard.formatCurrency(value);
                                
                                // Access the unitCounts passed from the main chart's dataset
                                const dataIndex = context.dataIndex;
                                const count = context.dataset.unitCounts ? context.dataset.unitCounts[dataIndex] : 0;
                                
                                const average = count > 0 ? value / count : 0;
                                const formattedAvg = window.dashboard.formatCurrency(average);

                                // --- NEW: Retrieve and format Avg PSM ---
                                const avgPsm = context.dataset.avgPsmData ? context.dataset.avgPsmData[dataIndex] : 0;
                                const formattedPsm = window.dashboard.formatCurrency(avgPsm);

                                return [
                                    `Sales: ${formattedSales}`,
                                    `Units: ${count}`,
                                    `Avg. Sales: ${formattedAvg}`,
                                    `Avg. PSM: ${formattedPsm}`
                                ];
                            };
                        }
                        
                        if (chartType === 'pie') {
                            modalOptions.cutout = 0;
                            modalOptions.elements = { arc: { borderWidth: 3, borderColor: '#fff' } };
                        }
                        const modalChart = new Chart(expandedCanvas, { type: chartType, data: originalData, options: modalOptions });
                        expandedCanvas.chartInstance = modalChart;
                    }, 100);
                }

                const closeBtn = document.createElement('button');
                closeBtn.className = 'chart-modal-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.style.cssText = `position: absolute; top: 15px; right: 15px; background: #dc3545; color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 2001; transition: background-color 0.2s ease;`;
                
                closeBtn.addEventListener('mouseenter', () => { closeBtn.style.backgroundColor = '#c82333'; });
                closeBtn.addEventListener('mouseleave', () => { closeBtn.style.backgroundColor = '#dc3545'; });

                const closeModal = () => {
                    if (isUnitMetricsChart) {
                        cleanupUnitMetricsChart(`${canvas.id}-modal`);
                    }
                    if (modal.parentNode) {
                        document.body.removeChild(modal);
                        document.body.style.overflow = '';
                    }
                };

                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeModal();
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal();
                    }
                });

                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        closeModal();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);

                container.appendChild(closeBtn);
                modal.appendChild(container);
                document.body.appendChild(modal);
                document.body.style.overflow = 'hidden';

            } catch (error) {
                console.error('Error expanding chart:', error);
                alert('Failed to expand chart. Please try again.');
            }
        }

        // Add this helper method to get chart title
        getChartTitle(canvasId) {
          const titleMap = {
              'salesTrendChart': 'Sales Trend',
              'deliveryProgressChart': 'Delivery Progress',
              'inventoryChart': 'Inventory Status',
              'unitModelChart': 'Unit Type Distribution',
              'contractPaymentPlanChart': 'Contract Payment Plan',
              'unitPriceChart': 'Unit Price Range',
              'unitPSMChart': 'Price per Square Meter Range',
              'unitAreaChart': 'Gross Area Range'
          };
          return titleMap[canvasId] || 'Chart';
        }

        calculateDeliveryComplianceData(units) {
          let onTimeCount = 0;
          let delayedCount = 0;
          let validUnits = []; // Track units that are included in the calculation
          
          units.forEach(unit => {
            if (!unit.contract_delivery_date || !unit.development_delivery_date) {
              return; // Skip units with missing dates
            }
            
            try {
              const contractDate = new Date(unit.contract_delivery_date);
              const developmentDate = new Date(unit.development_delivery_date);
              
              // Validate dates
              if (isNaN(contractDate.getTime()) || isNaN(developmentDate.getTime())) {
                return;
              }
              
              const adjustedContractDate = new Date(contractDate);
              adjustedContractDate.setMonth(adjustedContractDate.getMonth() + (parseInt(unit.grace_period_months) || 0));
              
              if (adjustedContractDate >= developmentDate) {
                onTimeCount++;
                validUnits.push({...unit, complianceStatus: 'on_time', monthsLate: 0});
              } else {
                const monthsLate = Math.ceil((developmentDate - adjustedContractDate) / (1000 * 60 * 60 * 24 * 30.44));
                delayedCount++;
                validUnits.push({...unit, complianceStatus: 'delayed', monthsLate: Math.max(0, monthsLate)});
              }
            } catch (error) {
              console.warn('Invalid date format for unit:', unit);
              return;
            }
          });
          
          // Store the valid units for modal use
          this._deliveryComplianceUnits = validUnits;
          
          return {
            labels: [`On Time (${onTimeCount})`, `Delayed (${delayedCount})`],
            data: [onTimeCount, delayedCount],
            validUnits: validUnits // Return for debugging
          };
        }


        // Add this method for high-resolution download
        downloadHighResChart(canvas) {
          try {
              const chartInstance = canvas.chartInstance;
              if (!chartInstance) {
                  this.downloadChart(canvas); // Fallback to regular download
                  return;
              }

              // Create a high-resolution canvas
              const highResCanvas = document.createElement('canvas');
              highResCanvas.width = canvas.width * 3; // Triple resolution for print quality
              highResCanvas.height = canvas.height * 3;
              
              const ctx = highResCanvas.getContext('2d');
              
              // Set high quality rendering
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              
              // Draw the original chart scaled up
              ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 
                          0, 0, highResCanvas.width, highResCanvas.height);

              const link = document.createElement('a');
              const chartName = this.getChartTitle(canvas.id).replace(/\s+/g, '_');
              link.download = `${chartName}_High_Resolution_${new Date().toISOString().slice(0,10)}.png`;
              link.href = highResCanvas.toDataURL('image/png', 1.0); // Maximum quality
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              
          } catch (error) {
              console.error('Error downloading high-res chart:', error);
              // Fallback to regular download
              this.downloadChart(canvas);
          }
        }

        async loadCompanyData(companyId) {
          if (!companyId) {
              this.clearDashboard();
              document.querySelector(".buttons").style.display = "none";
              return;
          }
          this.currentCompany = companyId;
          try {
              this.showLoading(true);
              this.resetPeriodSelectors();
              const url = `{% url 'get_company_units' %}?company_id=${companyId}`;
              const response = await fetch(url);
              const data = await response.json();
              this.units = data.units || [];
              document.querySelector(".buttons").style.display = "flex";
              // Initialize filters
              this.initFilters();


              this.updateFilterVisibility();

              //  Automatically clear selections once data loads
              if (typeof deselectAllFilters === "function") {
                deselectAllFilters();
              }
              

              // Initialize charts if not already done
              if (Object.keys(this.charts).length === 0) {
                  this.initCharts();
              }
              // Update dashboard
              this.updateDashboard();
          } catch (error) {
              console.error('Error loading company data:', error);
              alert('Failed to load company data. Please try again.');
          } finally {
              this.showLoading(false);
          }
        }

        clearDashboard() {
            // Clear all dashboard data
            this.units = [];
            this.updateKPIs([]);
            this.updateCharts([]);
            this.updateDataTable([]);
            document.getElementById("homeSection").innerHTML =
                "<h2>Welcome</h2><p>Select a company from the dropdown above.</p>";
        }
        initFilters() {
          // Get unique values for filters
          const projects = [...new Set(this.units.map(u => u.project))].filter(Boolean);
          const unitTypes = [...new Set(this.units.map(u => u.unit_type))].filter(Boolean);
          const contractPaymentPlans = [...new Set(this.units.map(u => u.contract_payment_plan))].filter(Boolean);
          const statuses = [...new Set(this.units.map(u => u.status))].filter(Boolean);
          const areas = [...new Set(this.units.map(u => u.area_range))].filter(Boolean);
          const cities = [...new Set(this.units.map(u => u.city))].filter(Boolean); // NEW: Get unique cities
          const owners = [...new Set(this.units.map(u => u.owner))].filter(Boolean);
          // Populate project filter checkboxes
          const projectFilter = document.getElementById("projectFilter");
          if (projectFilter) {
              projectFilter.innerHTML = projects.map(p => `<label><input type="checkbox" value="${p}" checked> ${p}</label>`).join('');
              // Add event listener for project filter
              projectFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              projectFilter.classList.remove('active');
              const projBtn = document.querySelector(`[onclick="toggleFilter('projectFilter')"]`);
              if (projBtn) projBtn.textContent = '[+]';
          }
          // Populate unit type filter checkboxes
          const unitTypeFilter = document.getElementById("unitTypeFilter");
          if (unitTypeFilter) {
              unitTypeFilter.innerHTML = unitTypes.map(t => `<label><input type="checkbox" value="${t}" checked> ${t}</label>`).join('');
              // Add event listener for unit type filter
              unitTypeFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              unitTypeFilter.classList.remove('active');
              const typeBtn = document.querySelector(`[onclick="toggleFilter('unitTypeFilter')"]`);
              if (typeBtn) typeBtn.textContent = '[+]';
          }

          // Populate unit type filter checkboxes
          const contractPaymentPlanFilter = document.getElementById("contractPaymentPlanFilter");
          if (contractPaymentPlanFilter) {
            contractPaymentPlanFilter.innerHTML = contractPaymentPlans.map(t => `<label><input type="checkbox" value="${t}" checked> ${t}</label>`).join('');
              // Add event listener for unit type filter
              contractPaymentPlanFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              contractPaymentPlanFilter.classList.remove('active');
              const typeBtn = document.querySelector(`[onclick="toggleFilter('contractPaymentPlanFilter')"]`);
              if (typeBtn) typeBtn.textContent = '[+]';
          }

          // Populate status filter checkboxes
          const statusFilter = document.getElementById("statusFilter");
          if (statusFilter) {
              statusFilter.innerHTML = statuses.map(s => `<label><input type="checkbox" value="${s}" checked> ${s}</label>`).join('');
              // Add event listener for status filter
              
              statusFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              statusFilter.classList.remove('active');
              const statBtn = document.querySelector(`[onclick="toggleFilter('statusFilter')"]`);
              if (statBtn) statBtn.textContent = '[+]';
          }
          // Populate area filter checkboxes
          const areaFilter = document.getElementById("areaFilter");
          if (areaFilter) {
              areaFilter.innerHTML = areas.map(a => `<label><input type="checkbox" value="${a}" checked> ${a}</label>`).join('');
              // Add event listener for area filter
              areaFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              areaFilter.classList.remove('active');
              const areaBtn = document.querySelector(`[onclick="toggleFilter('areaFilter')"]`);
              if (areaBtn) areaBtn.textContent = '[+]';
          }
          // Populate owener filter checkboxes
          const ownerFilter = document.getElementById("ownerFilter");
          if (ownerFilter) {
              ownerFilter.innerHTML = owners.map(a => `<label><input type="checkbox" value="${a}" checked> ${a}</label>`).join('');
              // Add event listener for area filter
              ownerFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              ownerFilter.classList.remove('active');
              const ownerBtn = document.querySelector(`[onclick="toggleFilter('ownerFilter')"]`);
              if (ownerBtn) ownerBtn.textContent = '[+]';
          }
          // Populate city filter checkboxes
          const cityFilter = document.getElementById("cityFilter");
          if (cityFilter) {
            cityFilter.innerHTML = cities.map(c => `<label><input type="checkbox" value="${c}" checked> ${c}</label>`).join('');
              // Add event listener for city filter
              cityFilter.addEventListener('change', () => this.updateFilters());
              // NEW: Ensure initial state is collapsed and button shows [+]
              cityFilter.classList.remove('active');
              const cityBtn = document.querySelector(`[onclick="toggleFilter('cityFilter')"]`);
              if (cityBtn) cityBtn.textContent = '[+]';
          }
        }


        updateFilterVisibility() {
            const filterKeys = Object.keys(this.filterConfig);

            // Iterate over each filter group (e.g., Projects, Unit Types...)
            filterKeys.forEach(targetKey => {
                const targetProp = this.filterConfig[targetKey].prop;
                const containerId = this.filterConfig[targetKey].id;

                // A. Find "Potential Units" for this specific group
                // We filter the master unit list based on selections in ALL OTHER groups
                const potentialUnits = this.units.filter(unit => {
                    return filterKeys.every(otherKey => {
                        // Skip the category we are currently updating (we want to see all valid options within this category)
                        if (otherKey === targetKey) return true;

                        const selectedValues = this.filters[otherKey];
                        // If no checkboxes selected in a group, it means "All" are valid
                        if (!selectedValues || selectedValues.length === 0) return true;

                        const otherProp = this.filterConfig[otherKey].prop;
                        return selectedValues.includes(unit[otherProp]);
                    });
                });

                // B. Extract unique available values for this category from the potential units
                const validValuesSet = new Set(potentialUnits.map(u => u[targetProp]));

                // C. Update DOM elements (Disable/Gray out invalid options)
                const container = document.getElementById(containerId);
                if (!container) return;

                const inputs = container.querySelectorAll('input[type="checkbox"]');
                
                inputs.forEach(input => {
                    const label = input.closest('label');
                    const val = input.value;

                    if (validValuesSet.has(val)) {
                        // Value is valid in current context
                        input.disabled = false;
                        if (label) {
                            label.style.opacity = '1';
                            label.style.color = '#333';
                            label.style.pointerEvents = 'auto';
                        }
                    } else {
                        // Value is invalid given other selections
                        input.disabled = true;
                        // input.checked = false; // Optional: Force uncheck if invalid
                        if (label) {
                            label.style.opacity = '0.4';
                            label.style.color = '#999';
                            label.style.pointerEvents = 'none';
                        }
                    }
                });
            });
        }
        updateFilters() {
            // 1. Capture current user selections using the config map
            Object.keys(this.filterConfig).forEach(key => {
                const containerId = this.filterConfig[key].id;
                const container = document.getElementById(containerId);
                
                if (container) {
                    this.filters[key] = Array.from(
                        container.querySelectorAll('input[type="checkbox"]:checked')
                    ).map(el => el.value);
                }
            });

            // 2. DEPENDENT LOGIC: Update UI availability based on selections
            this.updateFilterVisibility();

            // 3. Update Dashboard Charts/KPIs
            this.updateDashboard();
        }
        initCharts() {
            // Wait for DOM to be fully loaded before accessing elements
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    this._initializeCharts();
                });
            } else {
                // DOM is already loaded
                this._initializeCharts();
            }
        }
        _initializeCharts() {
            // Sales Trend Chart
            const salesTrendCanvas = document.getElementById("salesTrendChart");
            if (salesTrendCanvas) {
                this.charts.salesTrend = new Chart(
                    salesTrendCanvas, {
                        type: 'line',
                        data: { labels: [], datasets: [] },
                        options: this.getChartOptions('Sales Trend')
                    }
                );
                salesTrendCanvas.chartInstance = this.charts.salesTrend;
            } else {
                console.warn("Canvas with ID 'salesTrendChart' not found.");
            }

            // Delivery Analysis
            const deliveryChart = document.getElementById("deliveryProgressChart");
            if (deliveryChart) {
                this.charts.deliveryProgress = new Chart(
                    deliveryChart, {
                        type: 'line',
                        data: { labels: [], datasets: [] },
                        options: this.getChartOptions('Delivery Progress')
                    }
                );
                deliveryChart.chartInstance = this.charts.deliveryProgress;
            } else {
                console.warn("Canvas with ID 'deliveryProgressChart' not found.");
            }

            // Delivery Compliance Chart
            const deliveryComplianceCanvas = document.getElementById("deliveryComplianceChart");
            if (deliveryComplianceCanvas) {
                this.charts.deliveryCompliance = new Chart(
                    deliveryComplianceCanvas, {
                        type: 'pie',
                        data: { labels: [], datasets: [] },
                        options: this.getDeliveryComplianceChartOptions()
                    }
                );
                deliveryComplianceCanvas.chartInstance = this.charts.deliveryCompliance;
            } else {
                console.warn("Canvas with ID 'deliveryComplianceChart' not found.");
            }




            // Inventory Chart
            const inventoryCanvas = document.getElementById("inventoryChart");
            if (inventoryCanvas) {
                this.charts.inventory = new Chart(
                    inventoryCanvas, {
                        type: 'pie',
                        data: { labels: [], datasets: [] },
                        options: this.getChartOptions('Inventory Status')
                    }
                );
                inventoryCanvas.chartInstance = this.charts.inventory;
            } else {
                console.warn("Canvas with ID 'inventoryChart' not found.");
            }

            // Unit Type Chart
            const unitModelCanvas = document.getElementById("unitModelChart");
            if (unitModelCanvas) {
                this.charts.unitModel = new Chart(
                    unitModelCanvas, {
                        type: 'pie',
                        data: { labels: [], datasets: [] },
                        options: this.getChartOptions('Unit Type')
                    }
                );
                unitModelCanvas.chartInstance = this.charts.unitModel;
            } else {
                console.warn("Canvas with ID 'unitModelChart' not found.");
            }

            // Inside initializeCharts function (around where other charts are initialized)
            // Contract Payment Plan Chart (Bar Chart with smaller x-axis font)
            const contractPaymentPlanCanvas = document.getElementById("contractPaymentPlanChart");
            if (contractPaymentPlanCanvas) {
                this.charts.contractPaymentPlan = new Chart(contractPaymentPlanCanvas, {
                    type: 'bar', // Should already be 'bar' if converted previously
                    labels: [], 
                    datasets: [],
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false // Typically no legend for a single dataset bar chart like this
                            },
                            tooltip: {
                                // Keep your existing tooltip options here
                                enabled: true,
                                mode: 'index', // Show tooltip for the bar under the cursor index
                                intersect: false, // Don't require exact intersection
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: '#fff',
                                bodyColor: '#fff',
                                borderColor: 'rgba(255, 255, 255, 0.2)',
                                borderWidth: 1,
                                cornerRadius: 4,
                                displayColors: false,
                                callbacks: {
                                    // Keep your existing label callback logic here
                                    // Example placeholder, replace with your actual logic if different
                                    label: function(context) {
                                      const label = context.dataset.label || '';
                                      const value = context.parsed.y;
                                      
                                      // Calculate total for percentage
                                      const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                      const percentage = total > 0 ? ((value / total) * 100).toFixed(2) : 0;
                                      
                                      return [
                                          `${label}: ${value}`,
                                          `Percentage: ${percentage}%`
                                      ];
                                  }
                                }
                            }
                        },
                        scales: {
                            x: {
                                // Keep existing x-axis options like grid display
                                display: true,
                                grid: {
                                    display: false // Usually no vertical grid for bar charts
                                },
                                ticks: {
                                    // NEW: Set smaller font size for x-axis labels
                                    font: {
                                        size: 10 // Adjust this value (e.g., 9, 11) as needed
                                    },
                                    maxRotation: 90, // Allow more rotation if needed, default is usually 45
                                    minRotation: 0  // Minimum rotation
                                }
                            },
                            y: {
                                // Keep existing y-axis options
                                display: true,
                                beginAtZero: true,
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                },
                                title: {
                                    display: true,
                                    text: 'Number of Units' // Or whatever the y-axis represents
                                }
                            }
                        },
                        // Interaction might be useful for tooltips
                        interaction: {
                            mode: 'index', // Show tooltip for the bar under the cursor index
                            axis: 'x',     // Restrict to x-axis for bar charts
                            intersect: false // Don't require exact intersection
                        }
                    }
                });
                contractPaymentPlanCanvas.chartInstance = this.charts.contractPaymentPlan;
            } else {
                console.warn("Canvas with ID 'contractPaymentPlanChart' not found.");
            }

            
        }
        getChartOptions(title) {
            const isPieOrDoughnut = (title === 'Inventory Status' || title === 'Unit Type' || title === 'Unit Type Distribution');
            const isSalesLine = title.includes('Sales');
            const isDeliveryLine = title.includes('Delivery');
            const isPaymentPlan = title === 'Contract Payment Plan';

            const baseOptions = {
                responsive: true,
                maintainAspectRatio: false,
                // FIX: Differential interaction logic
                interaction: {
                    // Line/Bar: 'index' lets you hover the vertical slice. 'intersect: false' makes it easy to hit.
                    // Pie: 'nearest' + 'intersect: true' ensures you only trigger the specific slice you touch.
                    mode: isPieOrDoughnut ? 'nearest' : 'index',
                    intersect: isPieOrDoughnut ? true : false,
                    axis: isPieOrDoughnut ? undefined : 'x'
                },
                plugins: {
                    datalabels: {
                        display: (context) => context.dataset.data[context.dataIndex] > 0,
                        font: {
                            weight: 'bold',
                            size: 11
                        },
                        anchor: (context) => {
                            if (!isPieOrDoughnut) return isPaymentPlan ? 'end' : 'center';
                            const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                            const percentage = (context.dataset.data[context.dataIndex] / total) * 100;
                            return percentage < 5 ? 'end' : 'center';
                        },
                        align: (context) => {
                            if (!isPieOrDoughnut) return isPaymentPlan ? 'top' : 'center';
                            const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                            const percentage = (context.dataset.data[context.dataIndex] / total) * 100;
                            return percentage < 5 ? 'end' : 'center';
                        },
                        offset: (context) => {
                            if (!isPieOrDoughnut) return 2;
                            const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                            const percentage = (context.dataset.data[context.dataIndex] / total) * 100;
                            return percentage < 5 ? 10 : 0;
                        },
                        color: (context) => {
                            if (!isPieOrDoughnut) return '#444';
                            const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                            const percentage = (context.dataset.data[context.dataIndex] / total) * 100;
                            return percentage < 5 ? 'transparent' : '#fff'; // Dark color if outside pie
                        },
                        formatter: (value, context) => {
                            // 1. Pie Charts: % of Total
                            if (isPieOrDoughnut) {
                                const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                                return ((value / total) * 100).toFixed(1) + '%';
                            }
                            // 2. Bar Chart (Payment Plan): Unit Count
                            if (isPaymentPlan) return value;
                            // 3. Sales Line: 500k, 1.2M format
                            if (isSalesLine) {
                                if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                                if (value >= 1000) return (value / 1000).toFixed(0) + 'k';
                                return value;
                            }
                            // 4. Delivery Line: Raw count
                            if (isDeliveryLine) return value;
                            return null;
                        }
                    },
                    legend: {
                        onClick: (e, legendItem, legend) => {
                            const index = legendItem.datasetIndex;
                            const label = legend.chart.data.labels[index];
                            this.applyFilter(this.getFilterTypeFromChartId(legend.chart.canvas.id), label);
                        },
                        position: isPieOrDoughnut || isPaymentPlan ? 'bottom' : 'top',
                        labels: {
                            boxWidth: 12,
                            padding: 15
                        }
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        cornerRadius: 4,
                        displayColors: false,
                        callbacks: {
                            label: function(context) {
                                const label = context.label || context.dataset.label || '';
                                let value = context.parsed.y !== undefined ? context.parsed.y : context.parsed;

                                // --- CUSTOM LOGIC FOR SALES TREND ---
                                if (context.chart.canvas.id === 'salesTrendChart') {
                                    // 1. Get formatted Sales Value
                                    const formattedSales = window.dashboard.formatCurrency(value);

                                    // 2. Retrieve the count (Note: Must be passed in updateSalesTrendWithPeriod)
                                    const dataIndex = context.dataIndex;
                                    const count = context.dataset.unitCounts ? context.dataset.unitCounts[dataIndex] : 0;

                                    // 3. Calculate Average
                                    const average = count > 0 ? value / count : 0;
                                    const formattedAvg = window.dashboard.formatCurrency(average);

                                    // --- NEW: Retrieve and format Avg PSM ---
                                    const avgPsm = context.dataset.avgPsmData ? context.dataset.avgPsmData[dataIndex] : 0;
                                    const formattedPsm = window.dashboard.formatCurrency(avgPsm);


                                    // 4. Return Array for multiple lines
                                    return [
                                        `Sales: ${formattedSales}`,
                                        `Units: ${count}`,
                                        `Avg. Sales: ${formattedAvg}`,
                                        `Avg. PSM: ${formattedPsm}`
                                    ];
                                }
                                // --- END CUSTOM LOGIC ---

                                if (typeof value === 'number') {
                                    value = value.toLocaleString();
                                }
                                return `${label}: ${value}`;
                            },
                            beforeLabel: function(context) {
                                if (context.chart.config.type === 'pie') {
                                    // Only for specific pie charts
                                    const canvasId = context.chart.canvas.id;
                                    if (!['inventoryChart', 'unitModelChart', 'contractPaymentPlanChart'].includes(canvasId)) {
                                        return null;
                                    }

                                    const currentUnits = window.dashboard.getFilteredUnits();
                                    const label = context.label;

                                    let unitCount = 0;
                                    let salesValue = 0;
                                    let totalUnits = currentUnits.length;

                                    if (canvasId === 'inventoryChart' || canvasId.includes('inventoryChart')) {
                                        const statusCounts = window.dashboard.groupByStatus(currentUnits);
                                        unitCount = statusCounts[label] || 0;
                                        salesValue = currentUnits.filter(u => u.status === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                                    } else if (canvasId === 'unitModelChart' || canvasId.includes('unitModelChart')) {
                                        const modelCounts = window.dashboard.groupByUnitType(currentUnits);
                                        unitCount = modelCounts[label] || 0;
                                        salesValue = currentUnits.filter(u => u.unit_type === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                                    } else if (canvasId === 'contractPaymentPlanChart' || canvasId.includes('contractPaymentPlanChart')) {
                                        const planCounts = window.dashboard.groupByContractPaymentPlan(currentUnits);
                                        unitCount = planCounts[label] || 0;
                                        salesValue = currentUnits.filter(u => u.contract_payment_plan === label).reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
                                    }

                                    if (unitCount === 0) return null;

                                    const percentOfTotal = totalUnits > 0 ? ((unitCount / totalUnits) * 100).toFixed(2) : 0;

                                    return [
                                        `Number of Units: ${unitCount}`,
                                        `Total Sales Value: ${window.dashboard.formatCurrency(salesValue)}`,
                                        `% of Total Inventory: ${percentOfTotal}%`
                                    ];
                                }
                                return '';
                            }
                        }
                    }
                }, 
                onClick: (e, elements, chart) => {
                    if (elements.length > 0) {
                        try {
                            const element = elements[0];
                            const dataIndex = element.index;
                            const chartId = chart.canvas.id;
                            const chartType = chartId.replace("Chart", "");
                            const clickedLabel = chart.data.labels[dataIndex];

                            let filterType;
                            switch (chartType) {
                                case 'inventory': filterType = 'status'; break;
                                case 'unitType':
                                case 'unitModel': filterType = 'unitType'; break;
                                case 'contractPaymentPlan': filterType = 'contractPaymentPlan'; break;
                                default: filterType = 'project';
                            }

                            this.applyFilter(filterType, clickedLabel);
                        } catch (error) {
                            console.error('Error handling chart click:', error);
                        }
                    }
                }
            };

            if (title === 'Sales Trend' || title === 'Delivery Progress') {
                baseOptions.elements = {
                    line: { tension: 0.3 },
                    point: { radius: 4, hoverRadius: 8, hoverBorderWidth: 2, borderColor: '#fff' }
                };
                baseOptions.scales = {
                    x: { grid: { color: 'rgba(0, 0, 0, 0.1)' }, ticks: { maxRotation: 45 } },
                    y: {
                        grid: { color: 'rgba(0, 0, 0, 0.1)' },
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                                else if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
                                return value;
                            }
                        }
                    }
                };
            }

            if (isPieOrDoughnut || title === 'Contract Payment Plan') {
                if (isPieOrDoughnut) {
                    baseOptions.cutout = 0;
                    baseOptions.elements = { arc: { borderWidth: 2, borderColor: '#fff' } };
                }
                baseOptions.plugins.legend = {
                    ...baseOptions.plugins.legend,
                    position: 'bottom',
                    labels: { boxWidth: 12, padding: 15 }
                };
            }

            // Styling overrides for specific charts
            if (isSalesLine || isDeliveryLine) {
                baseOptions.plugins.datalabels.color = '#333'; // Dark text for lines
                baseOptions.plugins.datalabels.align = 'top';
                baseOptions.plugins.datalabels.offset = 5;
                baseOptions.elements = { line: { tension: 0.3 }, point: { radius: 4 } };
            }
            


            return baseOptions;
        }

        getDeliveryComplianceChartOptions() {
            return {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '0%',
                // FIX: Ensure correct hover behavior for Pie charts (strictly touch the slice)
                interaction: {
                    mode: 'nearest',
                    intersect: true
                },
                plugins: {

                    datalabels: {
                            color: '#fff',
                            font: { weight: 'bold' },
                            formatter: (value, context) => {
                                const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                                return ((value / total) * 100).toFixed(1) + '%';
                            }
                        },
                    legend: {
                        position: 'bottom',
                        labels: {
                            boxWidth: 12,
                            padding: 15,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        cornerRadius: 4,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.parsed;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${label}: ${value} units (${percentage}%)`;
                            }
                        }
                    }
                },
                elements: {
                    arc: {
                        borderWidth: 2,
                        borderColor: '#fff'
                    }
                }
            };
        }

        updateDeliveryComplianceChart(units) {
          const complianceData = this.calculateDeliveryComplianceData(units);
          
          const deliveryComplianceCanvas = document.getElementById("deliveryComplianceChart");
          if (deliveryComplianceCanvas && this.charts.deliveryCompliance) {
            this.charts.deliveryCompliance.data = {
              labels: complianceData.labels,
              datasets: [{
                data: complianceData.data,
                backgroundColor: ['#28a745', '#dc3545'],
                borderWidth: 2
              }]
            };
            this.charts.deliveryCompliance.update();
          }
          
          // Debug log to verify counts
          console.log('Delivery Compliance Calculation:', {
            totalUnits: units.length,
            validUnits: complianceData.validUnits.length,
            onTime: complianceData.data[0],
            delayed: complianceData.data[1],
            unitsWithMissingDates: units.length - complianceData.validUnits.length
          });
        }


        getFilterTypeFromChartId(chartId) {
            switch (chartId) {
                case 'inventoryChart':
                    return 'status';
                case 'unitTypeChart':
                    return 'unitType';
                case 'salesTrendChart':
                    return 'project';
                case 'deliveryTrendChart':
                    return 'project';
                case 'unitModelChart':
                    return 'unitModel';
                case 'contractPaymentPlanChart':
                    return 'contractPaymentPlan';
                default:
                    return 'project';
            }
        }
        applyFilter(filterName, value) {
          const filterContainer = document.getElementById(`${filterName}Filter`);
          if (filterContainer) {
              // Get current filter state
              const currentChecked = Array.from(
                  document.querySelectorAll(`#${filterName}Filter input:checked`)
              ).map(el => el.value);
              
              // If the clicked value is already the ONLY filter selected, do nothing
              // or clear the filter to show all
              if (currentChecked.length === 1 && currentChecked[0] === value) {
                  // Option 1: Clear this filter to show all
                  document.querySelectorAll(`#${filterName}Filter input`).forEach(input => {
                      input.checked = true;
                  });
              } else {
                  // Option 2: Set ONLY this filter
                  document.querySelectorAll(`#${filterName}Filter input`).forEach(input => {
                      input.checked = (input.value === value);
                  });
              }
              
              // Update filters and dashboard
              this.updateFilters();
          }
        }
        updateDashboard() {
          // 1. Get filtered data
          const filteredUnits = this.getFilteredUnits();

          // 2. Update all Dashboard components
          this.updateKPIs(filteredUnits);
          this.updateCharts(filteredUnits);
          this.updateDataTable(filteredUnits);
          this.updateUnitMetricsCharts(filteredUnits);

          // 3. Update Sales Trend Chart based on Period
          // Checks if the global variable exists; defaults to 'annually' if undefined
          const salesPeriod = (typeof currentSalesPeriod !== 'undefined') ? currentSalesPeriod : 'annually';
          updateChartByPeriod(salesPeriod);

          // 4. Update Delivery Analysis based on Period (optional, keeping your existing logic)
          // Checks DOM for active button, defaults to 'quarterly' if not found
          const activeDeliveryBtn = document.querySelector('#deliveryPeriodSelector .period-btn.active');
          const deliveryPeriod = activeDeliveryBtn ? activeDeliveryBtn.getAttribute('data-period') : 'annually';
          
          if (this.charts.deliveryProgress) {
              updateDeliveryChartByPeriod(deliveryPeriod);
          }
        }

        updateKPIs(units) {
          // Calculate totals for all units
          const totalUnits = units.length;
          const totalValue = units.reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
          const totalPSM = units.reduce((sum, u) => sum + (parseFloat(u.psm) || 0), 0);

          // Calculate totals for sold units
          const soldUnits = units.filter(u => u.status === 'Contracted' || u.status === 'Reserved');
          const soldCount = soldUnits.length;
          const soldValue = soldUnits.reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
          const soldPSM = soldUnits.reduce((sum, u) => sum + (parseFloat(u.psm) || 0), 0);

          // Calculate totals for unsold units
          const unsoldUnits = units.filter(u => u.status !== 'Contracted' && u.status !== 'Reserved');
          const unsoldCount = unsoldUnits.length;
          const unsoldValue = unsoldUnits.reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);
          const unsoldPSM = unsoldUnits.reduce((sum, u) => sum + (parseFloat(u.psm) || 0), 0);

          // --- MODIFIED AVERAGES (Using Sales Value) ---
          // Formerly calculated using interest_free_unit_price, now using totalValue/soldValue/unsoldValue
          const avgTotalPrice = totalUnits > 0 ? totalValue / totalUnits : 0;
          const avgSoldPrice = soldCount > 0 ? soldValue / soldCount : 0;
          const avgUnsoldPrice = unsoldCount > 0 ? unsoldValue / unsoldCount : 0;

          const avgTotalPSM = totalUnits > 0 ? totalPSM / totalUnits : 0;
          const avgSoldPSM = soldCount > 0 ? soldPSM / soldCount : 0;
          const avgUnsoldPSM = unsoldCount > 0 ? unsoldPSM / unsoldCount : 0;

          // Update the DOM elementsUnsold
          // Total Inventory KPI
          document.getElementById("totalInvCount").textContent = this.formatNumber(Math.round(totalUnits));
          document.getElementById("totalInvValue").textContent = this.formatNumber(Math.round(totalValue));
          document.getElementById("totalInvAvgPrice").textContent = this.formatNumber(Math.round(avgTotalPrice));
          document.getElementById("totalInvAvgPSM").textContent = this.formatNumber(Math.round(avgTotalPSM));

          // Sold Units KPI
          document.getElementById("soldCount").textContent = this.formatNumber(Math.round(soldCount));
          document.getElementById("soldValue").textContent = this.formatNumber(Math.round(soldValue));
          document.getElementById("soldAvgPrice").textContent = this.formatNumber(Math.round(avgSoldPrice));
          document.getElementById("soldAvgPSM").textContent = this.formatNumber(Math.round(avgSoldPSM));

          // Unsold Units KPI
          document.getElementById("unsoldCount").textContent = this.formatNumber(Math.round(unsoldCount));
          document.getElementById("unsoldValue").textContent = this.formatNumber(Math.round(unsoldValue));
          document.getElementById("unsoldAvgPrice").textContent = this.formatNumber(Math.round(avgUnsoldPrice));
          document.getElementById("unsoldAvgPSM").textContent = this.formatNumber(Math.round(avgUnsoldPSM));
        }

        updateCharts(units) {
            // this.updateSalesTrendChart(units);
            this.updateDeliveryTrendChart(units);
            this.updateDeliveryComplianceChart(units);
            this.updateInventoryChart(units);
            this.updateUnitTypeChart(units);
            this.updateUnitModelChart(units);
            this.updateContractPaymentPlanChart(units);
            this.updateUnitMetricsCharts(units);
        }
        updateSalesTrendChart(units) {
            const monthlySales = this.groupByMonth(units);
            const salesTrendCanvas = document.getElementById("salesTrendChart");
            if (salesTrendCanvas && this.charts.salesTrend) {
                 this.charts.salesTrend.data = {
                    labels: Object.keys(monthlySales),
                    datasets: [{
                        label: 'Sales Value',
                        data: Object.values(monthlySales).map(m => m.sales),
                        borderColor: '#D2691E',
                        backgroundColor: 'rgba(210, 105, 30, 0.1)',
                        tension: 0.3,
                        fill: true
                    }]
                };
                 this.charts.salesTrend.update();
            }
        }

        updateDeliveryTrendChart(units) {
          const monthlyDelivery = this.groupByDeliveryMonth(units);
          const deliveryTrendCanvas = document.getElementById("deliveryProgressChart");
          if (deliveryTrendCanvas && this.charts.deliveryProgress) { // Changed from deliveryTrend to deliveryProgress
              this.charts.deliveryProgress.data = { // Changed from deliveryTrend to deliveryProgress
                  labels: Object.keys(monthlyDelivery),
                  datasets: [{
                      label: 'Delivery Count',
                      data: Object.values(monthlyDelivery).map(m => m.count),
                      borderColor: '#28a745', // Green color for delivery
                      backgroundColor: 'rgba(40, 167, 69, 0.1)',
                      tension: 0.3,
                      fill: true
                  }]
              };
              this.charts.deliveryProgress.update(); // Changed from deliveryTrend to deliveryProgress
          }
        }

        updateInventoryChart(units) {
          const statusCounts = this.groupByStatus(units);
          
          // Filter out "Unknown" status
          const filteredStatusCounts = {};
          Object.keys(statusCounts).forEach(status => {
              if (status !== 'Unknown' && statusCounts[status] > 0) {
                  filteredStatusCounts[status] = statusCounts[status];
              }
          });
      
          const allStatuses = ['Available', 'Unreleased', 'Blocked Development', "Blocked Sales", "Blocked Cancellation", "Reserved", 'Contracted', 'Partner', 'Hold'];
          const labels = [];
          const data = [];
          const backgroundColors = [
              '#5B9BD5', // Blue
              '#ED7D31', // Orange
              '#A5A5A5', // Gray
              '#FFC000', // Yellow
              '#70AD47', // Green
              '#ac0202',
              '#8a6abd', // Black
              '#fff000',
              '#da0e8c'
          ];
      
          allStatuses.forEach((status, index) => {
              if (filteredStatusCounts[status] || this.filters.statuses.includes(status)) {
                  labels.push(status);
                  data.push(filteredStatusCounts[status] || 0);
              }
          });
      
          const inventoryCanvas = document.getElementById("inventoryChart");
          if (inventoryCanvas && this.charts.inventory) {
              this.charts.inventory.data = {
                  labels: labels,
                  datasets: [{
                      data: data,
                      backgroundColor: backgroundColors.slice(0, labels.length)
                  }]
              };
              this.charts.inventory.update();
          }
        }
        
        updateUnitModelChart(units) {
            const modelCounts = this.groupByUnitType(units);
            
            // Filter out "Unknown" unit types
            const filteredModelCounts = {};
            Object.keys(modelCounts).forEach(model => {
                if (model !== 'Unknown' && modelCounts[model] > 0) {
                    filteredModelCounts[model] = modelCounts[model];
                }
            });
        
            const unitModelCanvas = document.getElementById("unitModelChart");
            if (unitModelCanvas && this.charts.unitModel) {
                this.charts.unitModel.data = {
                    labels: Object.keys(filteredModelCounts),
                    datasets: [{
                        data: Object.values(filteredModelCounts),
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
                        ]
                    }]
                };
                this.charts.unitModel.update();
            }
        }
        
        updateContractPaymentPlanChart(units) {
          const planCounts = this.groupByContractPaymentPlan(units);
        
          // Filter out "Unknown" payment plans
          const filteredPlanCounts = {};
          Object.keys(planCounts).forEach(plan => {
              if (plan !== 'Unknown' && planCounts[plan] > 0) {
                  filteredPlanCounts[plan] = planCounts[plan];
              }
          });
        
          const contractPaymentPlanCanvas = document.getElementById("contractPaymentPlanChart");
          if (contractPaymentPlanCanvas && this.charts.contractPaymentPlan) {
              // --- CUSTOM Sorting Logic ---
              const labels = Object.keys(filteredPlanCounts);
              const data = Object.values(filteredPlanCounts);
        
              // Create an array of objects combining label and data
              const combinedArray = labels.map((label, index) => ({
                  label: label,
                  data: data[index]
              }));
        
              // Define custom order - put "cash" and other specific values first
              const customOrder = ['cash', 'Cash', 'CASH']; // Add variations if needed
        
              combinedArray.sort((a, b) => {
                  const aIndex = customOrder.indexOf(a.label.toLowerCase());
                  const bIndex = customOrder.indexOf(b.label.toLowerCase());
                  
                  // If both are in custom order, sort by custom order
                  if (aIndex !== -1 && bIndex !== -1) {
                      return aIndex - bIndex;
                  }
                  // If only A is in custom order, A comes first
                  if (aIndex !== -1) return -1;
                  // If only B is in custom order, B comes first
                  if (bIndex !== -1) return 1;
                  
                  // For other values (like "01 yr", "02 yr"), sort them naturally
                  // This will put "01 yr" before "02 yr", etc.
                  return a.label.localeCompare(b.label, undefined, { numeric: true, sensitivity: 'base' });
              });
        
              // Extract the sorted labels and data
              const sortedLabels = combinedArray.map(item => item.label);
              const sortedData = combinedArray.map(item => item.data);
              // --- End Sorting Logic ---
        
              // Calculate total units for percentage calculation in tooltip
              const totalUnits = this.units.length;
        
              this.charts.contractPaymentPlan.data = {
                  labels: sortedLabels, // Use the custom sorted labels
                  datasets: [{
                      label: 'Number of Units',
                      data: sortedData, // Use the data corresponding to sorted labels
                      backgroundColor: 'rgba(210, 105, 30, 0.6)', // Light dark orange with transparency
                      borderColor: 'rgba(210, 105, 30, 1)',      // Light dark orange solid
                      borderWidth: 1
                  }]
              };
        
              this.charts.contractPaymentPlan.update();
          }
        }

        updateUnitTypeChart(units) {
          const typeCounts = this.groupByUnitType(units);
          const unitTypeCanvas = document.getElementById("unitTypeChart");
          if (unitTypeCanvas && this.charts.unitType) {
               this.charts.unitType.data = {
                  labels: Object.keys(typeCounts),
                  datasets: [{
                      label: 'Units',
                      data: Object.values(typeCounts),
                      backgroundColor: '#D2691E'
                  }]
              };
               this.charts.unitType.update();
          }
        }

        // Add this new method to the Dashboard class
        updateUnitMetricsCharts(units) {
          if (!units) {
              console.error("Dashboard.updateUnitMetricsCharts: 'units' array is required.");
              return;
          }
          // Call the external function, passing the units and the dashboard instance if needed
          // Pass the dashboard's units array which is already filtered
          updateUnitMetricsCharts(units);
        }

        // Replace the existing updateDataTable method in your JS
        updateDataTable(units) {
            const table = document.getElementById('unitsTable');
            const tableBody = table.querySelector('tbody');
            if (!tableBody) return;

            // 1. Generate Data Rows
            tableBody.innerHTML = units.map(unit => `
            <tr>
                <td>${unit.project || '-'}</td>
                <td>${unit.unit_code ? unit.unit_code.split('_')[0] : '-'}</td>
                <td>${unit.unit_type || '-'}</td>
                <td>${this.formatNumber(unit.gross_area)}</td>
                <td>${unit.status || '-'}</td>
                <td>${this.formatCurrency(unit.interest_free_unit_price)}</td>
                <td>${this.formatCurrency(unit.sales_value)}</td>
                <td>${this.formatCurrency(unit.psm)}</td>
                <td>${unit.development_delivery_date || '-'}</td>
                <td>${unit.reservation_date || '-'}</td>
            </tr>
            `).join('');

            // 2. Calculate Totals
            // Sum up Interest Free Price
            const totalPrice = units.reduce((sum, u) => sum + (parseFloat(u.interest_free_unit_price) || 0), 0);
            // Sum up Sales Value (Optional but recommended)
            const totalSales = units.reduce((sum, u) => sum + (parseFloat(u.sales_value) || 0), 0);

            // 3. Update or Create Footer
            let tfoot = table.querySelector('tfoot');
            if (!tfoot) {
                tfoot = document.createElement('tfoot');
                table.appendChild(tfoot);
            }

            // 4. Render Footer Row
            // We use colspan="5" to span Project, Code, Type, Area, Status columns
            tfoot.innerHTML = `
                <tr>
                    <td colspan="5" style="text-align: right; padding-right: 20px;">Grand Total:</td>
                    <td>${this.formatCurrency(totalPrice)}</td>
                    <td>${this.formatCurrency(totalSales)}</td>
                    <td colspan="3"></td> </tr>
            `;
            
            // Optional: Re-apply the search filter logic if needed (handled by the search input event listener usually)
        }

        groupByMonth(units) {
            const months = {};
            units.forEach(unit => {
                if (unit.reservation_date) {
                    const date = new Date(unit.reservation_date);
                    const monthYear = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (!months[monthYear]) {
                        months[monthYear] = { sales: 0, count: 0 };
                    }
                    months[monthYear].sales += parseFloat(unit.sales_value) || 0;
                    months[monthYear].count++;
                }
            });
            return Object.keys(months)
                .sort()
                .reduce((obj, key) => {
                    obj[key] = months[key];
                    return obj;
                }, {});
        }

        groupByDeliveryMonth(units) {
          const months = {};

          units.forEach(unit => {
              if (unit.development_delivery_date) {
                  const date = new Date(unit.development_delivery_date);
                  const monthYear = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                  if (!months[monthYear]) {
                      months[monthYear] = { count: 0 };
                  }
                  months[monthYear].count++;
              }
          });
          
          return Object.keys(months)
              .sort()
              .reduce((obj, key) => {
                  obj[key] = months[key];
                  return obj;
              }, {});
        }

        groupByStatus(units) {
          const statuses = {};
          units.forEach(unit => {
              const status = unit.status || 'Unknown';
              // Only count if status is not "Unknown"
              if (status !== 'Unknown') {
                  statuses[status] = (statuses[status] || 0) + 1;
              }
          });
          return statuses;
        }
        groupByUnitType(units) {
            const types = {};
            units.forEach(unit => {
                const type = unit.unit_type || 'Unknown';
                // Only count if type is not "Unknown"
                if (type !== 'Unknown') {
                    types[type] = (types[type] || 0) + 1;
                }
            });
            return types;
        }
        groupByContractPaymentPlan(units) {
            const plans = {};
            units.forEach(unit => {
                const plan = unit.contract_payment_plan || 'Unknown';
                // Only count if plan is not "Unknown"
                if (plan !== 'Unknown') {
                    plans[plan] = (plans[plan] || 0) + 1;
                }
            });
            return plans;
        }
        groupByUnitModel(units) {
          const models = {};
          units.forEach(unit => {
              const model = unit.unit_model || 'Unknown';
              models[model] = (models[model] || 0) + 1;
          });
          return models;
        }
        exportData() {
            const filteredUnits = this.getFilteredUnits();
            const ws = XLSX.utils.json_to_sheet(filteredUnits);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Units Data");
            XLSX.writeFile(wb, `Units_Export_${new Date().toISOString().slice(0,10)}.xlsx`);
        }
        
        showLoading(show) {
            const loader = document.getElementById("dashboardLoader");
            if (show) {
                if (!loader) {
                    const loaderDiv = document.createElement('div');
                    loaderDiv.id = 'dashboardLoader';
                    loaderDiv.className = 'dashboard-loader';
                    loaderDiv.innerHTML = `
                <div class="loader-spinner"></div>
                <p>Loading data...</p>
              `;
                    document.querySelector('.dashboard-container').appendChild(loaderDiv);
                }
            } else if (loader) {
                loader.remove();
            }
        }
        formatNumber(num) {
            const value = parseFloat(num);
            if (isNaN(value)) return '-';
            return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
        }
        formatCurrency(num) {
            const value = parseFloat(num);
            if (isNaN(value)) return '-';
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'EGP',
                maximumFractionDigits: 0
            }).format(value);
        }
        // Add methods to set date ranges
        setSalesDateRange(startDate, endDate) {
          this.filters.salesDateRange.start = startDate;
          this.filters.salesDateRange.end = endDate;
          this.updateDashboard();
        }

        setDeliveryDateRange(startDate, endDate) {
          this.filters.deliveryDateRange.start = startDate;
          this.filters.deliveryDateRange.end = endDate;
          this.updateDashboard();
        }

        // Clear date ranges
        clearSalesDateRange() {
          this.filters.salesDateRange.start = null;
          this.filters.salesDateRange.end = null;
          this.updateDashboard();
        }

        clearDeliveryDateRange() {
          this.filters.deliveryDateRange.start = null;
          this.filters.deliveryDateRange.end = null;
          this.updateDashboard();
        }

        // Update the getFilteredUnits method to include date filtering
        getFilteredUnits() {
          const filtered = this.units.filter(unit => {
              const matchesBasicFilters = (
                  (this.filters.projects.length === 0 || this.filters.projects.includes(unit.project)) &&
                  (this.filters.unitTypes.length === 0 || this.filters.unitTypes.includes(unit.unit_type)) &&
                  (this.filters.contractPaymentPlans.length === 0 || this.filters.contractPaymentPlans.includes(unit.contract_payment_plan)) &&
                  (this.filters.statuses.length === 0 || this.filters.statuses.includes(unit.status)) &&
                  (this.filters.areas.length === 0 || this.filters.areas.includes(unit.area_range)) &&
                  (this.filters.cities.length === 0 || this.filters.cities.includes(unit.city)) &&
                  (this.filters.owners.length === 0 || this.filters.owners.includes(unit.owner)) 
              );

              if (!matchesBasicFilters) return false;

              // Apply date range filters
              const matchesSalesDate = this.matchesSalesDateRange(unit);
              const matchesDeliveryDate = this.matchesDeliveryDateRange(unit);

              // If both date ranges are set, unit must match at least one
              if (this.filters.salesDateRange.start && this.filters.deliveryDateRange.start) {
                  return matchesSalesDate || matchesDeliveryDate;
              }
              // If only sales date range is set
              else if (this.filters.salesDateRange.start) {
                  return matchesSalesDate;
              }
              // If only delivery date range is set
              else if (this.filters.deliveryDateRange.start) {
                  return matchesDeliveryDate;
              }
              // No date filters applied
              return true;
          });
          
          return filtered;
        }

        matchesSalesDateRange(unit) {
          const { start, end } = this.filters.salesDateRange;
          if (!start && !end) return true;

          if (!unit.reservation_date) return false;
          
          const reservationDate = new Date(unit.reservation_date);
          if (isNaN(reservationDate.getTime())) return false;

          const afterStart = !start || reservationDate >= start;
          const beforeEnd = !end || reservationDate <= end;
          
          return afterStart && beforeEnd;
        }

        matchesDeliveryDateRange(unit) {
          const { start, end } = this.filters.deliveryDateRange;
          if (!start && !end) return true;

          if (!unit.development_delivery_date) return false;
          
          const deliveryDate = new Date(unit.development_delivery_date);
          if (isNaN(deliveryDate.getTime())) return false;

          const afterStart = !start || deliveryDate >= start;
          const beforeEnd = !end || deliveryDate <= end;
          
          return afterStart && beforeEnd;
        }
      }
      // Initialize dashboard when DOM is loaded
      document.addEventListener("DOMContentLoaded", () => {
          window.dashboard = new Dashboard();
      });
      // Add CSS for loader and modal
      const loaderStyles = document.createElement('style');
      loaderStyles.textContent = `
          .dashboard-loader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
          }
          .loader-spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #D2691E;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
          }
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          .chart-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
          }
          .chart-modal-container {
            position: relative;
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
          }
          .chart-modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc3545;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
          }
        `;
      document.head.appendChild(loaderStyles);
    </script>


    <script>
      // Period Selector Functionality for Sales Trend
      document.addEventListener('DOMContentLoaded', function() {
          const salesPeriodButtons = document.querySelectorAll('.period-btn:not(#deliveryPeriodSelector .period-btn)'); 
          
          // MODIFICATION 1: Change default to 'annually'
          let currentSalesPeriod = 'annually'; 

          salesPeriodButtons.forEach(button => {
              button.addEventListener('click', function() {
                  const period = this.getAttribute('data-period');
                  salesPeriodButtons.forEach(btn => {
                      btn.classList.remove('active');
                  });
                  this.classList.add('active');
                  currentSalesPeriod = period;
                  updateChartByPeriod(period); 
              });
          });

          // MODIFICATION 1: Initialize with 'annually'
          setTimeout(() => updateChartByPeriod('annually'), 100); 
      });


      // Function to clean up unit metrics chart resources (destroys Chart instance, observers, and boxes)
      function cleanupUnitMetricsChart(canvasId) {
        // ensure globals exist
        window.unitMetricsCharts = window.unitMetricsCharts || {};
        window.unitMetricsScrollHandlers = window.unitMetricsScrollHandlers || {};

        // Remove event handlers and observers
        const handlers = window.unitMetricsScrollHandlers[canvasId];
        if (handlers) {
          try { handlers.resizeObserver?.disconnect(); } catch {}
          if (handlers.scroll) {
            const canvas = document.getElementById(canvasId);
            const canvasContainer = canvas?.closest('.unit-metrics-chart-canvas-container');
            if (canvasContainer) {
              try { canvasContainer.removeEventListener('scroll', handlers.scroll); } catch {}
            }
          }
          delete window.unitMetricsScrollHandlers[canvasId];
        }

        // Destroy Chart.js instance safely
        const chart = window.unitMetricsCharts[canvasId] || Chart.getChart(canvasId);
        if (chart) {
          try { chart.destroy(); } catch (e) { console.debug('Destroy chart error:', e); }
          delete window.unitMetricsCharts[canvasId];
        }

        // Remove any value boxes left
        document.querySelectorAll(`.unit-metrics-value-box[data-chart="${canvasId}"]`).forEach(el => el.remove());
      }
      
      function updateChartByPeriod(period) {
          // Get current date-filtered units
          const dateFilteredUnits = getDateFilteredUnits();
          
          // ---------------------------------------------------------
          // MODIFICATION: Filter strictly for 'Contracted' units only
          // ---------------------------------------------------------
          const contractedUnits = dateFilteredUnits.filter(unit => unit.status === 'Contracted' || unit.status === 'Reserved');
          
          // Group data based on selected period using ONLY the contracted units
          const groupedData = groupSalesDataByPeriod(contractedUnits, period);
          
          // Update sales trend chart
          updateSalesTrendWithPeriod(groupedData, period);
      }
      
      function getDateFilteredUnits() {
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        
        const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
        const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
    
        // Get the current filtered units from dashboard
        const filteredUnits = window.dashboard.getFilteredUnits();
        
        // Filter ALL units by reservation date within the selected range
        return filteredUnits.filter(unit => {
            if (!unit.reservation_date) return false;
            
            const reservationDate = new Date(unit.reservation_date);
            
            // Check if date is valid
            if (isNaN(reservationDate.getTime())) return false;
            
            // Check if date is within range
            const afterStart = !startDate || reservationDate >= startDate;
            const beforeEnd = !endDate || reservationDate <= endDate;
            
            return afterStart && beforeEnd;
        });
      }
      
      // Add the grouping function
      function groupSalesDataByPeriod(units, period) {
        const grouped = {};
        units.forEach(unit => {
            if (!unit.reservation_date) return;
            const date = new Date(unit.reservation_date);
            if (isNaN(date.getTime())) return;

            let periodKey = '';
            let label = '';
            switch(period) {
                case 'monthly':
                    periodKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    label = new Date(date.getFullYear(), date.getMonth(), 1).toLocaleDateString('en-US', {year: 'numeric', month: 'short'});
                    break;
                case 'quarterly':
                    const quarter = Math.floor(date.getMonth() / 3) + 1;
                    periodKey = `${date.getFullYear()}-Q${quarter}`;
                    label = `Q${quarter} ${date.getFullYear()}`;
                    break;
                case 'annually':
                    periodKey = `${date.getFullYear()}`;
                    label = `${date.getFullYear()}`;
                    break;
            }

            if (!grouped[periodKey]) {
                // Initialize psmTotal here
                grouped[periodKey] = { sales: 0, count: 0, psmTotal: 0, label: label };
            }
            grouped[periodKey].sales += parseFloat(unit.sales_value) || 0;
            // Sum up the PSM
            grouped[periodKey].psmTotal += parseFloat(unit.psm) || 0;
            grouped[periodKey].count += 1;
        });

        return Object.keys(grouped).sort().map(key => ({
            period: key,
            label: grouped[key].label,
            sales: grouped[key].sales,
            count: grouped[key].count,
            // Return the sum so we can average it later
            psmTotal: grouped[key].psmTotal 
        }));
      }
      
      function updateSalesTrendWithPeriod(data, period) {
        const salesTrendCanvas = document.getElementById("salesTrendChart");
     
        if (salesTrendCanvas && window.dashboard.charts.salesTrend) {
            const labels = data.map(item => item.label);
            const salesData = data.map(item => item.sales);
            const countData = data.map(item => item.count);

            // --- NEW: Calculate Average PSM Array ---
            const avgPsmData = data.map(item => item.count > 0 ? item.psmTotal / item.count : 0);
     
            let chartTitle = 'Sales Trend';
            switch(period) {
                case 'monthly': chartTitle = 'Monthly Sales Trend'; break;
                case 'quarterly': chartTitle = 'Quarterly Sales Trend'; break;
                case 'annually': chartTitle = 'Annual Sales Trend'; break;
            }
     
            const chartContainer = salesTrendCanvas.closest('.chart-card');
            if (chartContainer) {
                const chartHeader = chartContainer.querySelector('.chart-header h3');
                if (chartHeader) {
                    chartHeader.textContent = chartTitle;
                }
            }
     
            const newData = {
                labels: labels,
                datasets: [{
                    label: 'Sales Value',
                    data: salesData,
                    unitCounts: countData,
                    // --- NEW: Pass Average PSM data to dataset ---
                    avgPsmData: avgPsmData, 
                    borderColor: '#D2691E',
                    backgroundColor: 'rgba(210, 105, 30, 0.1)',
                    tension: 0.3,
                    fill: true,
                    pointBackgroundColor: '#D2691E',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                }]
            };
     
            window.dashboard.charts.salesTrend.data = newData;
     
            const scales = {
                x: { title: { display: true, text: getXAxisLabel(period) } },
                y: { title: { display: true, text: 'Sales Value' }, beginAtZero: true }
            };
     
            if (window.dashboard.charts.salesTrend.options && window.dashboard.charts.salesTrend.options.scales) {
                window.dashboard.charts.salesTrend.options.scales = scales;
            }
     
            window.dashboard.charts.salesTrend.update();
        }
      }

      
      function getXAxisLabel(period) {
          switch(period) {
              case 'monthly':
                  return 'Months';
              case 'quarterly':
                  return 'Quarters';
              case 'annually':
                  return 'Years';
              default:
                  return 'Time Period';
          }
      }
      
      // Update the existing date range filter to also consider period
      function applyDateRangeFilter() {
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        
        const startDate = startDateInput.value ? new Date(startDateInput.value) : null;
        const endDate = endDateInput.value ? new Date(endDateInput.value) : null;
    
        // Validate date range
        if (startDate && endDate && startDate > endDate) {
            alert('Start date cannot be after end date');
            return;
        }
    
        // Set the date range in dashboard - this will filter ALL units
        if (window.dashboard) {
            window.dashboard.setSalesDateRange(startDate, endDate);
            
            // This will trigger updateDashboard() which updates KPIs, charts, and data table
            // with ALL units filtered by the date range
            window.dashboard.updateDashboard();
        }
    
        // Get current period for the sales trend chart specifically
        const activePeriodBtn = document.querySelector('.period-btn.active');
        if (activePeriodBtn) {
            const activePeriod = activePeriodBtn.getAttribute('data-period');
            // Update sales trend chart with current period and new date range
            updateChartByPeriod(activePeriod);
        }
      }
      
      // Also update the existing date range initialization to work with period selector
      document.addEventListener('DOMContentLoaded', function() {
          const startDateInput = document.getElementById('startDate');
          const endDateInput = document.getElementById('endDate');
          const applyDateRangeBtn = document.getElementById('applyDateRange');
          const clearDateRangeBtn = document.getElementById('clearDateRange');
      
          // Set default date range to empty
          if (startDateInput && endDateInput) {
            startDateInput.value = '';
            endDateInput.value = '';
          }

      
          // Apply date range filter
          if (applyDateRangeBtn) {
              applyDateRangeBtn.addEventListener('click', function() {
                  applyDateRangeFilter();
              });
          }
      
          // Clear date range filter
          if (clearDateRangeBtn) {
              clearDateRangeBtn.addEventListener('click', function() {
                  if (startDateInput) startDateInput.value = '';
                  if (endDateInput) endDateInput.value = '';
                  applyDateRangeFilter(); // This will reset to show all data
              });
          }
      
          // Apply filter when dates change
          if (startDateInput) startDateInput.addEventListener('change', applyDateRangeFilter);
          if (endDateInput) endDateInput.addEventListener('change', applyDateRangeFilter);
      });
    </script> 

    <script>
      // Period Selector Functionality for Delivery Progress
      // In the DOMContentLoaded event for delivery period buttons
      document.addEventListener('DOMContentLoaded', function() {
        const deliveryPeriodButtons = document.querySelectorAll('#deliveryPeriodSelector .period-btn');
        let currentDeliveryPeriod = 'quarterly';
        deliveryPeriodButtons.forEach(button => {
            button.addEventListener('click', function() {
                const period = this.getAttribute('data-period');
                deliveryPeriodButtons.forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                currentDeliveryPeriod = period;
                updateDeliveryChartByPeriod(period);
            });
        });

        // Initialize delivery chart with current filtered data
        setTimeout(() => updateDeliveryChartByPeriod('annually'), 100);
      });

      // Date Range Selector Functionality for Delivery Progress
      document.addEventListener('DOMContentLoaded', function() {
        const applyDeliveryBtn = document.getElementById('applyDeliveryDateRange');
        const deliveryStartDateInput = document.getElementById('deliveryStartDate');
        const deliveryEndDateInput = document.getElementById('deliveryEndDate');

        // Add event listener to the Apply button
        if (applyDeliveryBtn) {
            applyDeliveryBtn.addEventListener('click', applyDeliveryDateRangeFilter);
        }

        // Optionally, add event listeners to the date inputs themselves (triggers on change)
        // This updates the chart as soon as a date is selected, without needing to click Apply
        if (deliveryStartDateInput) {
            deliveryStartDateInput.addEventListener('change', applyDeliveryDateRangeFilter);
        }
        if (deliveryEndDateInput) {
            deliveryEndDateInput.addEventListener('change', applyDeliveryDateRangeFilter);
        }

        // Also, ensure the Clear button works if it exists (add this if needed)
        const clearDeliveryBtn = document.getElementById('clearDeliveryDateRange');
        if (clearDeliveryBtn) {
            clearDeliveryBtn.addEventListener('click', function() {
                if (deliveryStartDateInput) deliveryStartDateInput.value = '';
                if (deliveryEndDateInput) deliveryEndDateInput.value = '';
                // Re-trigger the filter with empty dates to show all data
                applyDeliveryDateRangeFilter();
            });
        }
      });
            
      function updateDeliveryChartByPeriod(period) {
          // Get current date-filtered units
          const deliveryDateFilteredUnits = getDeliveryDateFilteredUnits();
          
          // Group data based on selected period
          const deliveryGroupedData = groupDeliveryDataByPeriod(deliveryDateFilteredUnits, period);
          
          // Update Delivery Analysis
          updateDeliveryProgressWithPeriod(deliveryGroupedData, period);
      }
      
      function getDeliveryDateFilteredUnits() {
        const deliveryStartDateInput = document.getElementById('deliveryStartDate');
        const deliveryEndDateInput = document.getElementById('deliveryEndDate');
        const startDate = deliveryStartDateInput.value ? new Date(deliveryStartDateInput.value) : null;
        const endDate = deliveryEndDateInput.value ? new Date(deliveryEndDateInput.value) : null;
    
        // Get the CURRENTLY FILTERED units from dashboard (after all main filters are applied)
        const filteredUnits = window.dashboard.getFilteredUnits(); // This applies all active filters
    
        // Filter units by development delivery date within the selected range
        return filteredUnits.filter(unit => {
            if (!unit.development_delivery_date) return false;
    
            const deliveryDate = new Date(unit.development_delivery_date);
    
            // Check if date is valid
            if (isNaN(deliveryDate.getTime())) return false;
    
            // Check if date is within range
            const afterStart = !startDate || deliveryDate >= startDate;
            const beforeEnd = !endDate || deliveryDate <= endDate;
            return afterStart && beforeEnd;
        });
      }
      
      function groupDeliveryDataByPeriod(units, period) {
        const deliveryGrouped = {};
        
        units.forEach(unit => {
            if (!unit.development_delivery_date) return;
            
            const date = new Date(unit.development_delivery_date);
            
            // Check if date is valid
            if (isNaN(date.getTime())) return;
            
            let periodKey = '';
            let label = '';
            
            switch(period) {
                case 'monthly':
                    periodKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    label = new Date(date.getFullYear(), date.getMonth(), 1).toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'short' 
                    });
                    break;
                    
                case 'quarterly':
                    const quarter = Math.floor(date.getMonth() / 3) + 1;
                    periodKey = `${date.getFullYear()}-Q${quarter}`;
                    label = `Q${quarter} ${date.getFullYear()}`;
                    break;
                    
                case 'annually':
                    periodKey = `${date.getFullYear()}`;
                    label = `${date.getFullYear()}`;
                    break;
            }
            
            if (!deliveryGrouped[periodKey]) {
                deliveryGrouped[periodKey] = { 
                    count: 0, // Count of deliveries instead of sales value
                    label: label
                };
            }
            
            deliveryGrouped[periodKey].count++;
        });
        
        // Convert to sorted array and return
        return Object.keys(deliveryGrouped)
            .sort()
            .map(key => ({
                period: key,
                label: deliveryGrouped[key].label,
                count: deliveryGrouped[key].count
            }));
      }
      
      function updateDeliveryProgressWithPeriod(data, period) {
        const deliveryProgressCanvas = document.getElementById("deliveryProgressChart");
        
        if (deliveryProgressCanvas && window.dashboard.charts.deliveryProgress) {
            const labels = data.map(item => item.label);
            const deliveryData = data.map(item => item.count); // Use count instead of sales value
            
            // Update chart title based on period
            let chartTitle = 'Delivery Analysis';
            switch(period) {
                case 'monthly':
                    chartTitle = 'Monthly Delivery Progress';
                    break;
                case 'quarterly':
                    chartTitle = 'Quarterly Delivery Progress';
                    break;
                case 'annually':
                    chartTitle = 'Annual Delivery Progress';
                    break;
            }
            
            // Update chart header if needed
            const chartHeader = document.querySelector('.chart-header h3');
            if (chartHeader && chartHeader.textContent.includes('Delivery')) {
                chartHeader.textContent = chartTitle;
            }
            
            // Create a clean dataset with light dark orange color
            const newData = {
                labels: labels,
                datasets: [{
                    label: 'Number of Deliveries',
                    data: deliveryData,
                    borderColor: '#D2691E', // Light dark orange
                    backgroundColor: 'rgba(210, 105, 30, 0.1)', // Light orange with transparency
                    tension: 0.3,
                    fill: true,
                    pointBackgroundColor: '#D2691E',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                }]
            };
            
            // Update only the data, not the entire chart configuration
            window.dashboard.charts.deliveryProgress.data = newData;
            
            // Update scales without causing recursion
            const scales = {
                x: {
                    title: {
                        display: true,
                        text: getDeliveryXAxisLabel(period)
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Number of Deliveries'
                    },
                    beginAtZero: true
                }
            };
            
            // Safely update scales without recursion
            if (window.dashboard.charts.deliveryProgress.options && window.dashboard.charts.deliveryProgress.options.scales) {
                window.dashboard.charts.deliveryProgress.options.scales = scales;
            }
            
            window.dashboard.charts.deliveryProgress.update();
        }
      }
      
      function getDeliveryXAxisLabel(period) {
          switch(period) {
              case 'monthly':
                  return 'Months';
              case 'quarterly':
                  return 'Quarters';
              case 'annually':
                  return 'Years';
              default:
                  return 'Time Period';
          }
      }
      
      // Update the existing date range filter to also consider period
      function applyDeliveryDateRangeFilter() {
        const deliveryStartDateInput = document.getElementById('deliveryStartDate');
        const deliveryEndDateInput = document.getElementById('deliveryEndDate');
        
        const startDate = deliveryStartDateInput.value ? new Date(deliveryStartDateInput.value) : null;
        const endDate = deliveryEndDateInput.value ? new Date(deliveryEndDateInput.value) : null;

        // Validate date range
        if (startDate && endDate && startDate > endDate) {
            alert('Start date cannot be after end date');
            return;
        }

        // Set the date range in dashboard
        if (window.dashboard) {
          window.dashboard.setDeliveryDateRange(startDate, endDate);
        }

        // Get current period - FIXED SELECTOR
        const activeDeliveryPeriodBtn = document.querySelector('#deliveryPeriodSelector .period-btn.active');

        if (activeDeliveryPeriodBtn) {
            const activePeriod = activeDeliveryPeriodBtn.getAttribute('data-period');
            console.log("Active period:", activePeriod);
            // Update chart with current period and new date range
            updateDeliveryChartByPeriod(activePeriod);
        } else {
            // Fallback: if no active button found, use default period
            console.log("No active period button found, defaulting to annually");
            updateDeliveryChartByPeriod('annually');
        }
      }
      
      // Also update the existing date range initialization to work with period selector
      document.addEventListener('DOMContentLoaded', function() {
        const deliveryStartDateInput = document.getElementById('deliveryStartDate');
        const deliveryEndDateInput = document.getElementById('deliveryEndDate');
        const applyDeliveryDateRangeBtn = document.getElementById('applyDeliveryDateRange');
        const clearDeliveryDateRangeBtn = document.getElementById('clearDeliveryDateRange');

        // Set default date range to empty
        if (deliveryStartDateInput && deliveryEndDateInput) {
            deliveryStartDateInput.value = '';
            deliveryEndDateInput.value = '';
        }
            
        // Apply date range filter
        if (applyDeliveryDateRangeBtn) {
            applyDeliveryDateRangeBtn.addEventListener('click', function() {
                applyDeliveryDateRangeFilter();
            });
        }

        // Clear date range filter
        if (clearDeliveryDateRangeBtn) {
            clearDeliveryDateRangeBtn.addEventListener('click', function() {
                if (deliveryStartDateInput) deliveryStartDateInput.value = '';
                if (deliveryEndDateInput) deliveryEndDateInput.value = '';
                applyDeliveryDateRangeFilter(); // This will reset to show all data
            });
        }

        // Apply filter when dates change
        if (deliveryStartDateInput) deliveryStartDateInput.addEventListener('change', applyDeliveryDateRangeFilter);
        if (deliveryEndDateInput) deliveryEndDateInput.addEventListener('change', applyDeliveryDateRangeFilter);
      });
    </script>

    <!-- Add this new script tag after the existing scripts in your template -->
    <script>
      // Function to format numbers specifically for these metrics
      function formatUnitMetricNumber(num, metricType) {
        if (num === null || num === undefined || isNaN(num)) return 'N/A';
        // Use minimumFractionDigits: 0 and maximumFractionDigits: 0 to remove decimals
        // Add conditional formatting based on metricType
        const options = {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
            // Add thousands separators for better readability
            useGrouping: true
        };

        // Apply specific formatting for interest_free_unit_price
        if (metricType === 'interest_free_unit_price') {
            // You can add a currency symbol if desired, e.g., USD
            // options.style = 'currency';
            // options.currency = 'USD'; // Replace with your desired currency
            // For simple number formatting without currency:
            options.style = undefined; // Ensure no currency style if not wanted
        }
        // Add other metric-specific formatting here if needed in the future

        return num.toLocaleString(undefined, options);
      }


      // Function to aggregate data by unit type for the new charts
      function aggregateDataByUnitType(units, valueField) {
          const aggregated = {};
          units.forEach(unit => {
              const unitType = unit.unit_type || 'Unknown';
              const value = parseFloat(unit[valueField]); // Ensure it's a number
              if (!isNaN(value)) {
                  if (!aggregated[unitType]) {
                      aggregated[unitType] = [];
                  }
                  aggregated[unitType].push(value);
              }
          });

          const labels = Object.keys(aggregated);
          const dataPoints = labels.map(label => {
              const values = aggregated[label];
              if (values.length === 0) return null;
              const sorted = values.sort((a, b) => a - b);
              const min = sorted[0];
              const max = sorted[sorted.length - 1];
              const avg = values.reduce((sum, v) => sum + v, 0) / values.length;
              return { min: min, avg: avg, max: max };
          });

          return { labels: labels, dataPoints: dataPoints };
      }


      // Function to render a single unit metrics chart
      function renderUnitMetricsChart(canvasId, units, valueField, chartTitle, chartColor = '#D2691E', isModal = false) {
        // 1. Setup Globals
        window.unitMetricsCharts = window.unitMetricsCharts || {};
        window.unitMetricsScrollHandlers = window.unitMetricsScrollHandlers || {};
        window.unitMetricsTimeouts = window.unitMetricsTimeouts || {};

        // 2. CANCEL PENDING RENDER
        if (window.unitMetricsTimeouts[canvasId]) {
            clearTimeout(window.unitMetricsTimeouts[canvasId]);
        }

        // 3. CLEANUP
        if (window.unitMetricsScrollHandlers[canvasId]) {
            try {
                window.unitMetricsScrollHandlers[canvasId].resizeObserver?.disconnect();
                const scrollTarget = window.unitMetricsScrollHandlers[canvasId].scrollTarget;
                const scrollFn = window.unitMetricsScrollHandlers[canvasId].scroll;
                if (scrollTarget && scrollFn) {
                    scrollTarget.removeEventListener('scroll', scrollFn);
                }
            } catch (e) { console.warn('Cleanup warning:', e); }
            delete window.unitMetricsScrollHandlers[canvasId];
        }
        
        const containerForCleanup = document.getElementById(canvasId)?.parentNode;
        if(containerForCleanup) {
            containerForCleanup.querySelectorAll(`.unit-metrics-value-box[data-chart="${canvasId}"]`).forEach(el => el.remove());
            const oldTooltip = containerForCleanup.querySelector(`#tooltip-${canvasId}`);
            if(oldTooltip) oldTooltip.remove();
        }

        // 4. QUEUE NEW RENDER
        window.unitMetricsTimeouts[canvasId] = setTimeout(() => {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !canvas.isConnected) return;

            const existingChart = Chart.getChart(canvas);
            if (existingChart) existingChart.destroy();

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            // Aggregate data
            const { labels, dataPoints } = aggregateDataByUnitType(units, valueField);

            // Handle Empty Data
            const hasData = dataPoints.some(point => point !== null);
            if (!hasData) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = "16px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = "#6c757d";
                ctx.fillText("No data available", canvas.width / 2, canvas.height / 2);
                return;
            }

            // Calculate Scale
            let suggestedYMax = null;
            let suggestedYMin = null;
            const allValues = dataPoints.flatMap(p => p ? [p.min, p.avg, p.max] : []);
            if (allValues.length > 0) {
                const dataMax = Math.max(...allValues);
                const dataMin = Math.min(...allValues);
                const range = dataMax - dataMin || 1;
                suggestedYMax = dataMax + range * 0.1;
                suggestedYMin = Math.max(0, dataMin - range * 0.05);
            }

            // Settings
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile && !isModal ? 8 : 10;
            const boxWidth = isMobile && !isModal ? 45 : 55;
            const boxHeight = isMobile && !isModal ? 16 : 18;
            const lineWidth = isMobile && !isModal ? 2 : 3;

            // --- External Tooltip Handler ---
            const externalTooltipHandler = (context) => {
                // Tooltip Element
                const {chart, tooltip} = context;
                const tooltipElId = `tooltip-${canvasId}`;
                let tooltipEl = document.getElementById(tooltipElId);

                if (!tooltipEl) {
                    tooltipEl = document.createElement('div');
                    tooltipEl.id = tooltipElId;
                    tooltipEl.style.background = 'rgba(0, 0, 0, 0.8)';
                    tooltipEl.style.borderRadius = '0px';
                    tooltipEl.style.color = 'black';
                    tooltipEl.style.opacity = 1;
                    tooltipEl.style.pointerEvents = 'none';
                    tooltipEl.style.position = 'absolute';
                    // Initial styles
                    tooltipEl.style.transition = 'all .1s ease';
                    tooltipEl.style.zIndex = '100'; // Above value boxes
                    tooltipEl.style.padding = '1px';
                    tooltipEl.style.fontFamily = 'Helvetica Neue, Helvetica, Arial, sans-serif';
                    tooltipEl.style.fontSize = '5px';
                    chart.canvas.parentNode.appendChild(tooltipEl);
                }

                // Hide if no tooltip
                if (tooltip.opacity === 0) {
                    tooltipEl.style.opacity = 0;
                    return;
                }

                // Set Content
                if (tooltip.body) {
                    const titleLines = tooltip.title || [];
                    const bodyLines = tooltip.body.map(b => b.lines);

                    let innerHtml = '<thead>';

                    innerHtml += '</thead><tbody>';

                    bodyLines.forEach(function(body, i) {
                        // Only show the relevant lines (Range stats)
                        body.forEach(line => {
                            innerHtml += '<tr><td style="padding: 0; line-height: 1.2;">' + line + '</td></tr>';
                        });
                    });
                    innerHtml += '</tbody>';

                    const tableRoot = tooltipEl.querySelector('table');
                    if(tableRoot) {
                        tableRoot.innerHTML = innerHtml;
                    } else {
                        tooltipEl.innerHTML = '<table style="margin:0; padding:0; border-spacing:0;">' + innerHtml + '</table>';
                    }
                }

                const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;

                // --- CUSTOM POSITIONING LOGIC ---
                // 1. Identify the hovered data index
                if (tooltip.dataPoints && tooltip.dataPoints.length > 0) {
                    const dataIndex = tooltip.dataPoints[0].dataIndex;
                    
                    // 2. Get the "Range" dataset (index 0) which contains the Max value in a bar chart
                    const meta = chart.getDatasetMeta(0);
                    const maxBarElement = meta.data[dataIndex];

                    if (maxBarElement) {
                        // 3. Calculate exact pixel position of the top of the bar (Max Value)
                        // maxBarElement.y corresponds to the value of the bar
                        const targetY = maxBarElement.y;

                        // 4. Apply positions
                        tooltipEl.style.opacity = 1;
                        tooltipEl.style.left = positionX + tooltip.caretX + 'px'; // Keep X centered
                        
                        // Set Top relative to the canvas Y position + the Max Value Y position
                        // Subtract a small buffer (e.g., 5px) to add spacing
                        tooltipEl.style.top = (positionY + targetY - 5) + 'px'; 
                        
                        // 5. Translate Y by -100% to sit *above* the target point
                        tooltipEl.style.transform = 'translate(-50%, -100%)'; 
                    }
                }
                
            };

            // --- Chart Configuration ---
            const config = {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Range',
                            data: dataPoints.map(p => p ? p.max : null),
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            showLine: false,
                            order: 1
                        },
                        {
                            label: 'Average',
                            data: dataPoints.map(p => p ? p.avg : null),
                            type: 'line',
                            fill: false,
                            borderColor: 'transparent',
                            backgroundColor: 'transparent',
                            borderWidth: 0,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            showLine: false,
                            order: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    // INCREASED TOP PADDING to allow space for "Always Above" tooltips
                    layout: { padding: { top: isMobile ? 50 : 40, bottom: isMobile ? 30 : 20 } },
                    scales: {
                        y: {
                            min: suggestedYMin,
                            max: suggestedYMax,
                            grid: { color: 'rgba(0, 0, 0, 0.1)', drawBorder: true },
                            title: { display: true, text: chartTitle, font: { size: isMobile ? 12 : 14 } },
                            ticks: { font: { size: isMobile ? 10 : 12 }, padding: 5 }
                        },
                        x: {
                            display: true,
                            grid: { display: false },
                            ticks: {
                                maxRotation: isMobile ? 90 : 45,
                                minRotation: isMobile ? 45 : 0,
                                font: { size: isMobile ? 10 : 12 }
                            }
                        }
                    },
                    interaction: { 
                        mode: 'index', 
                        axis: 'x', 
                        intersect: false 
                    },
                    plugins: {
                        datalabels: { display: false }, // Disable default labels here
                        legend: { display: false },
                        tooltip: {
                            enabled: false, // External tooltip enabled
                            external: externalTooltipHandler,
                            callbacks: {
                                title: (tooltipItems) => tooltipItems[0].label,
                                label: (context) => {
                                    const dataIndex = context.dataIndex;
                                    const rawDataPoint = dataPoints[dataIndex];
                                    if (!rawDataPoint) return null;
                                    if (context.datasetIndex !== 0) return null; 

                                    let fieldName = 'Value';
                                    if (valueField === 'interest_free_unit_price') fieldName = 'Price';
                                    else if (valueField === 'psm') fieldName = 'PSM';
                                    else if (valueField === 'gross_area') fieldName = 'Area';

                                    return [
                                      `Max: ${formatUnitMetricNumber(rawDataPoint.max, valueField)}`,
                                      `Avg: ${formatUnitMetricNumber(rawDataPoint.avg, valueField)}`,
                                      `Min: ${formatUnitMetricNumber(rawDataPoint.min, valueField)}`
                                    ];
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'customUnitMetricsRenderer',
                    afterDatasetsDraw: function(chart) {
                        if (!chart.ctx) return;
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0);
                        const yScale = chart.scales.y;
                        const chartContainer = chart.canvas.parentNode;

                        if (!chartContainer) return;

                        // Clean up existing boxes
                        chartContainer.querySelectorAll(`.unit-metrics-value-box[data-chart="${canvasId}"]`).forEach(el => el.remove());

                        dataPoints.forEach((dataPoint, index) => {
                            if (!dataPoint || !meta.data[index]) return;

                            const x = meta.data[index].x;
                            const minY = yScale.getPixelForValue(dataPoint.min);
                            const maxY = yScale.getPixelForValue(dataPoint.max);
                            const avgY = yScale.getPixelForValue(dataPoint.avg);

                            // Draw Line
                            ctx.save();
                            ctx.strokeStyle = chartColor;
                            ctx.lineWidth = lineWidth;
                            ctx.beginPath();
                            ctx.moveTo(x, minY);
                            ctx.lineTo(x, maxY);
                            ctx.stroke();
                            ctx.restore();

                            // Draw Boxes (Z-INDEX 10)
                            const makeBox = (value, topPx, extraCss) => {
                                if (isNaN(value)) return;
                                const box = document.createElement('div');
                                box.className = 'unit-metrics-value-box';
                                box.setAttribute('data-chart', canvasId);
                                box.textContent = formatUnitMetricNumber(value, valueField);
                                
                                const baseStyle = `
                                    position: absolute; transform: translate(-50%, -50%); z-index: 10;
                                    display: flex; align-items: center; justify-content: center;
                                    white-space: nowrap; pointer-events: none;
                                    padding: 0px; box-sizing: border-box; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                                    font-size: ${fontSize}px; width: ${boxWidth}px; height: ${boxHeight}px;
                                `;
                                
                                box.style.cssText = baseStyle + `left: ${x}px; top: ${topPx}px; ${extraCss}`;
                                chartContainer.appendChild(box);
                            };

                            makeBox(dataPoint.min, minY, `background-color: white; color: black; border: 1px solid #666;`);
                            makeBox(dataPoint.avg, avgY, `background-color: ${chartColor}; color: white; border: 1px solid #A0522D;`);
                            makeBox(dataPoint.max, maxY, `background-color: white; color: black; border: 1px solid #666;`);
                        });
                    }
                }]
            };

            try {
                window.unitMetricsCharts[canvasId] = new Chart(ctx, config);
            } catch (e) {
                console.error('Chart creation failed:', e);
            }

            let rafId = null;
            function safeUpdate() {
                if (rafId) cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(() => {
                    const c = window.unitMetricsCharts[canvasId];
                    const cvs = document.getElementById(canvasId);
                    if (c && cvs && cvs.isConnected && c.ctx && !c._destroyed) { 
                        c.update('none'); 
                    }
                });
            }
            const resizeObserver = new ResizeObserver(() => safeUpdate());
            resizeObserver.observe(canvas);
            const canvasContainer = canvas.closest('.unit-metrics-chart-canvas-container');
            if (canvasContainer) {
                canvasContainer.addEventListener('scroll', safeUpdate, { passive: true });
            }
            window.unitMetricsScrollHandlers[canvasId] = { resizeObserver, scroll: safeUpdate, scrollTarget: canvasContainer };

        }, 100);
      }




      // Function to update all three new charts based on current units
      function updateUnitMetricsCharts(units) {
          if (!units) {
              console.error("updateUnitMetricsCharts: 'units' array is required.");
              return;
          }

          ['unitPriceChart', 'unitPSMChart', 'unitAreaChart'].forEach(chartId => {
              cleanupUnitMetricsChart(chartId);
          });

          // MODIFICATION 3: Change 'interest_free_unit_price' to 'sales_value'
          // Also updated title to reflect it is now Sales Value
          renderUnitMetricsChart('unitPriceChart', units, 'sales_value', 'Unit Price Range (Sales Value)', '#D2691E');
          
          renderUnitMetricsChart('unitPSMChart', units, 'psm', 'Price per Square Meter (PSM)', '#D2691E');
          renderUnitMetricsChart('unitAreaChart', units, 'gross_area', 'Gross Area (sqm)', '#D2691E');
      }

      // Example: Call updateUnitMetricsCharts when dashboard filters change
      // Assuming your existing dashboard logic updates `currentUnits` and calls update functions
      // You would integrate this call like so (this is conceptual based on your existing code structure):
      /*
      // Inside your main dashboard object or update logic, after `currentUnits` is updated:
      updateUnitMetricsCharts(window.dashboard.currentUnits); // Or wherever your filtered units are stored
      */
    </script>

    <script>
      // Scroll to top when page loads or refreshes
      window.addEventListener('load', function() {
        window.scrollTo(0, 0);
      });
      
      // Also scroll to top when the page is shown from back/forward cache
      window.addEventListener('pageshow', function(event) {
        if (event.persisted) {
          window.scrollTo(0, 0);
        }
      });
    
      // Scroll to top when dashboard refreshes
      document.addEventListener('DOMContentLoaded', function() {
        window.scrollTo(0, 0);
        
        // If there's a refresh button, make it scroll to top too
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', function() {
            setTimeout(() => {
              window.scrollTo(0, 0);
            }, 100);
          });
        }
      });

      // Declare jspdf globally if not already done by the script tag
      // window.jspdf is defined by the jspdf.umd.min.js script
      const { jsPDF } = window.jspdf;

      /**
      * Downloads the dashboard as a PDF.
      * Each chart gets its own page in A4 landscape format.
      * The data table is excluded.
      * Improved quality for charts using high-resolution canvas rendering or scaled html2canvas.
      */
      async function downloadDashboardReport() {
        console.log("Starting dashboard PDF download with high-quality charts...");

        const dashboardContainer = document.querySelector('body'); // Or e.g., document.getElementById('dashboardWrapper')

        if (!dashboardContainer) {
            console.error("Dashboard container not found.");
            alert("Dashboard content not found. Cannot generate report.");
            return;
        }

        try {
            const chartElements = dashboardContainer.querySelectorAll('.chart-card canvas');
            console.log(`Found ${chartElements.length} chart elements to include.`);

            if (chartElements.length === 0) {
                console.warn("No chart elements found to include in the report.");
                alert("No charts found to include in the report.");
                return;
            }

            const pdf = new jsPDF('l', 'mm', 'a4');
            const pdfWidth = pdf.internal.pageSize.getWidth(); // 297mm
            const pdfHeight = pdf.internal.pageSize.getHeight(); // 210mm
            let isFirstPage = true;

            for (let i = 0; i < chartElements.length; i++) {
                const chartElement = chartElements[i];
                const chartId = chartElement.id;
                console.log(`Processing chart ${i + 1}: ${chartId || 'unnamed canvas'}`);

                if (!isFirstPage) {
                    pdf.addPage();
                } else {
                    isFirstPage = false;
                }

                const chartCard = chartElement.closest('.chart-card');
                const allChartCards = dashboardContainer.querySelectorAll('.chart-card');
                const elementsToHide = [];

                // Hide other charts and the table
                allChartCards.forEach(card => {
                    if (card !== chartCard) {
                        elementsToHide.push({ element: card, display: card.style.display });
                        card.style.display = 'none';
                    }
                });
                const tableContainer = dashboardContainer.querySelector('#pivotTableContainer, #invPivotTableContainer, #salesPivotTableContainer, #deliveryPivotTableContainer');
                if (tableContainer) {
                    elementsToHide.push({ element: tableContainer, display: tableContainer.style.display });
                    tableContainer.style.display = 'none';
                }

                try {
                    let imgData;
                    let originalCanvasWidth = chartElement.width;
                    let originalCanvasHeight = chartElement.height;

                    // --- High-Quality Capture Logic ---
                    // Check if the canvas is associated with a Chart.js instance via the attached property
                    const chartInstance = chartElement.chartInstance; // Assuming you attached it like: canvas.chartInstance = myChart;

                    if (chartInstance) {
                        console.log(`Chart.js instance found for ${chartId}, rendering at high DPI.`);
                        // Get the chart's internal canvas (the one Chart.js draws on)
                        const internalCanvas = chartInstance.canvas;
                        const internalCtx = internalCanvas.getContext('2d');

                        // Determine a high DPI scale factor (e.g., 2x or 3x for print quality)
                        const dpiScale = 3; // Increase this if needed, but be mindful of memory/performance

                        // Create a temporary high-resolution canvas
                        const highResCanvas = document.createElement('canvas');
                        highResCanvas.width = internalCanvas.width * dpiScale;
                        highResCanvas.height = internalCanvas.height * dpiScale;

                        const highResCtx = highResCanvas.getContext('2d');

                        // Set high quality rendering for the high-res canvas
                        highResCtx.imageSmoothingEnabled = true;
                        highResCtx.imageSmoothingQuality = 'high';

                        // Scale the context to draw the original chart content at high resolution
                        highResCtx.scale(dpiScale, dpiScale);
                        // Draw the *internal* chart canvas content onto the high-res canvas
                        // This captures the actual chart rendering, not the potentially scaled HTML element
                        highResCtx.drawImage(internalCanvas, 0, 0);

                        // Convert the high-resolution canvas to image data
                        imgData = highResCanvas.toDataURL('image/png');
                        console.log(`Captured high-res image for ${chartId} using Chart.js instance.`);
                    } else {
                        console.warn(`No Chart.js instance found for ${chartId || 'unnamed canvas'}, falling back to high-scale html2canvas.`);
                        // Fallback to html2canvas of the chart card if no Chart.js instance is found or attached
                        // This captures the chart card element which includes the header and the canvas
                        const canvas = await html2canvas(chartCard, {
                            scale: 3, // Use a high scale (e.g., 3x) for better quality in the fallback
                            useCORS: true,
                            logging: false,
                            backgroundColor: window.getComputedStyle(chartCard).backgroundColor || '#ffffff'
                        });
                        imgData = canvas.toDataURL('image/png');
                        console.log(`Captured image for ${chartId || 'unnamed'} using high-scale html2canvas fallback.`);
                    }
                    // --- End High-Quality Capture Logic ---

                    // Calculate dimensions based on the captured image data dimensions
                    const tempImg = new Image();
                    tempImg.src = imgData;
                    await new Promise((resolve) => { tempImg.onload = resolve; }); // Wait for image to load to get dimensions

                    const imgWidth = tempImg.width;
                    const imgHeight = tempImg.height;

                    // Calculate dimensions to fit the image within the PDF page while maintaining aspect ratio
                    const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight, 1);
                    const imgFinalWidth = imgWidth * ratio;
                    const imgFinalHeight = imgHeight * ratio;

                    // Calculate position to center the image on the page
                    const xPosition = (pdfWidth - imgFinalWidth) / 2;
                    const yPosition = (pdfHeight - imgFinalHeight) / 2;

                    // Add the high-quality image to the current PDF page
                    pdf.addImage(imgData, 'PNG', xPosition, yPosition, imgFinalWidth, imgFinalHeight);

                    console.log(`Successfully added high-quality chart ${i + 1} (${chartId || 'unnamed'}) to PDF page ${pdf.getNumberOfPages()}.`);

                } catch (captureError) {
                    console.error(`Error capturing chart ${i + 1} (${chartId || 'unnamed'}):`, captureError);
                    pdf.text(`Error capturing chart: ${chartId || 'unnamed'}`, 10, 10);
                } finally {
                    // Restore the visibility of hidden elements
                    elementsToHide.forEach(item => {
                        item.element.style.display = item.display;
                    });
                }
            }

            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `Dashboard_Report_${timestamp}.pdf`; // Ensure the filename ends with .pdf

            pdf.save(filename);
            console.log("Dashboard PDF download completed successfully with improved quality.");

        } catch (error) {
            console.error("Error generating dashboard PDF:", error);
            alert("An error occurred while generating the report. Please check the console for details.");
        }
      }




    </script>

    <script>
      (function () {
        // Wait until dashboard & chart exist
        function ready(fn){ document.readyState !== 'loading' ? fn() : document.addEventListener('DOMContentLoaded', fn); }
      
        ready(function () {
          const canvas = document.getElementById('deliveryComplianceChart');
          if (!canvas) return;
      
          // Avoid double-binding
          if (canvas.dataset.dcBound === '1') return;
          canvas.dataset.dcBound = '1';
      
          function calculateDeliveryStatus(unit) {
            // If unit already has compliance status from dashboard calculation, use it
            if (unit.complianceStatus) {
              return { 
                status: unit.complianceStatus, 
                monthsLate: unit.monthsLate || 0 
              };
            }
            
            // Fallback to original calculation for units not processed by dashboard
            if (!unit || !unit.contract_delivery_date || !unit.development_delivery_date || unit.grace_period_months === null) 
              return { status: 'unknown', monthsLate: 0 };
            
            try {
              const contractDate = new Date(unit.contract_delivery_date);
              const developmentDate = new Date(unit.development_delivery_date);
              const adjustedContractDate = new Date(contractDate);
              adjustedContractDate.setMonth(adjustedContractDate.getMonth() + (parseInt(unit.grace_period_months) || 0));
              
              if (adjustedContractDate >= developmentDate) {
                return { status: 'on_time', monthsLate: 0 };
              } else {
                const monthsLate = Math.ceil((developmentDate - adjustedContractDate) / (1000 * 60 * 60 * 24 * 30.44));
                return { status: 'delayed', monthsLate: Math.max(0, monthsLate) };
              }
            } catch (e) {
              return { status: 'unknown', monthsLate: 0 };
            }
          }
      
          function fmtDate(d) {
            if (!d) return '-';
            const dt = new Date(d);
            return isNaN(dt) ? '-' : dt.toLocaleDateString('en-GB', { year: 'numeric', month: 'short', day: '2-digit' });
          }
          
          function fmtNum(n){ return (window.dashboard && window.dashboard.formatNumber) ? window.dashboard.formatNumber(n) : (n ?? '-'); }
          function fmtEGP(n){ return (window.dashboard && window.dashboard.formatCurrency) ? window.dashboard.formatCurrency(n) : (n ?? '-'); }
      
          function buildRows(units) {
            return units.map(u => {
              const deliveryStatus = calculateDeliveryStatus(u);
              let statusDisplay = '-';
              let statusStyle = '';
              
              if (deliveryStatus.status === 'on_time') {
                statusDisplay = 'On Time';
                statusStyle = 'color:#28a745; font-weight:600;';
              } else if (deliveryStatus.status === 'delayed') {
                const months = deliveryStatus.monthsLate;
                statusDisplay = `${months} month${months !== 1 ? 's' : ''} late`;
                statusStyle = 'color:#dc3545; font-weight:600;';
              }
              
              return `
                <tr>
                  <td>${u.project || '-'}</td>
                  <td>${u.unit_code ? u.unit_code.split('_')[0] : '-'}</td>
                  <td>${u.unit_type || '-'}</td>
                  <td>${fmtNum(u.gross_area)}</td>
                  <td>${u.status || '-'}</td>
                  <td>${fmtEGP(u.sales_value)}</td>
                  <td>${fmtNum(u.psm)}</td>
                  <td>${fmtDate(u.contract_delivery_date)}</td>
                  <td>${u.grace_period_months ?? '-'}</td>
                  <td>${fmtDate(u.development_delivery_date)}</td>
                  <td style="${statusStyle}">${statusDisplay}</td>
                </tr>
              `;
            }).join('');
          }
      
          function openUnitsModal(title, units) {
            // Overlay
            const overlay = document.createElement('div');
            overlay.className = 'chart-modal';
            overlay.style.cssText = `
              position:fixed; inset:0; background:rgba(0,0,0,.9); z-index:2000;
              display:flex; align-items:center; justify-content:center; padding:20px; box-sizing:border-box;
            `;
      
            // Container
            const box = document.createElement('div');
            box.className = 'chart-modal-container';
            box.style.cssText = `
              position:relative; background:#fff; border-radius:12px; padding:24px;
              max-width:95vw; max-height:95vh; overflow:auto; width:100%;
            `;
      
            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'chart-modal-close';
            closeBtn.innerHTML = '&times;';
            closeBtn.setAttribute('aria-label','Close');
            closeBtn.style.cssText = `
              position:absolute; top:12px; right:12px; width:40px; height:40px; border:none;
              border-radius:50%; background:#db4040; cursor:pointer; font-size:24px; line-height:1;
            `;
      
            // Header
            const h3 = document.createElement('h3');
            h3.textContent = title;
            h3.style.cssText = `margin:0 0 14px 0; color:#333; font-size:22px; font-weight:600;`;
      
            // Table wrapper (scrollable & responsive)
            const wrap = document.createElement('div');
            wrap.style.cssText = `
              width:100%; overflow:auto; border:1px solid #eee; border-radius:8px;
              max-height:70vh; -webkit-overflow-scrolling:touch;
            `;
      
            // Sticky header table
            const table = document.createElement('table');
            table.style.cssText = `
              width:100%; border-collapse:collapse; font-size:13px; min-width:920px;
            `;
            table.innerHTML = `
              <thead style="position:sticky; top:0; z-index:1; background:#f5f5f5;">
                <tr>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Project</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Unit Code</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Unit Type</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Area</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Status</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Price</th>
                  <th style="text-align:right; padding:10px 12px; border-bottom:1px solid #eee;">PSM</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Contract Delivery Date</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Grace (m)</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Delivery Date</th>
                  <th style="text-align:center; padding:10px 12px; border-bottom:1px solid #eee;">Compliance</th>
                </tr>
              </thead>
              <tbody>
                ${buildRows(units)}
              </tbody>
            `;
            // Row hover
            table.querySelectorAll('tbody tr').forEach(tr=>{
              tr.addEventListener('mouseenter',()=>tr.style.backgroundColor='#f9f9f9');
              tr.addEventListener('mouseleave',()=>tr.style.backgroundColor='');
            });
      
            wrap.appendChild(table);
            box.appendChild(closeBtn);
            box.appendChild(h3);
            box.appendChild(wrap);
            overlay.appendChild(box);
            document.body.appendChild(overlay);
            document.body.classList.add('modal-open');
      
            function close() {
              document.body.classList.remove('modal-open');
              overlay.remove();
              document.removeEventListener('keydown', esc);
            }
            function esc(e){ if (e.key === 'Escape') close(); }
      
            overlay.addEventListener('click', (e)=>{ if (e.target === overlay) close(); });
            closeBtn.addEventListener('click', close);
            document.addEventListener('keydown', esc);
          }
      
          // Attach click => open modal with filtered units for the clicked slice
          // Replace the modal opening section in the pie chart click handler
          canvas.addEventListener('click', function (evt) {
            const chart = canvas.chartInstance || (window.dashboard && window.dashboard.charts && window.dashboard.charts.deliveryCompliance);
            if (!chart) return;

            const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
            if (!points.length) return;

            const idx = points[0].index;
            const label = chart.data.labels?.[idx] || '';
            const chooseOnTime = label.toLowerCase().includes('on time') || idx === 0;

            // Use the pre-calculated delivery compliance units instead of filtering again
            const validUnits = window.dashboard._deliveryComplianceUnits || [];
            
            const units = validUnits.filter(u => {
              return chooseOnTime ? u.complianceStatus === 'on_time' : u.complianceStatus === 'delayed';
            });

            // Debug log to verify modal data matches pie chart
            console.log('Modal Data Check:', {
              pieChartLabel: label,
              pieChartCount: chart.data.datasets[0].data[idx],
              modalUnitsCount: units.length,
              expectedMatch: chart.data.datasets[0].data[idx] === units.length
            });

            const title = `${label}  ${units.length} unit${units.length===1?'':'s'}`;
            openUnitsModal(title, units);
          }, { passive: true });
        });
      })();
    </script>
      

    <script>
      document.addEventListener('DOMContentLoaded', function() {
          // Create search input for Unit Code header
          const unitCodeHeader = document.querySelector('#unitsTable th:nth-child(2)');
          if (unitCodeHeader) {
              // Store original header text
              const originalText = unitCodeHeader.textContent;
              
              // Create search input
              const searchInput = document.createElement('input');
              searchInput.type = 'text';
              searchInput.placeholder = 'Unit Code';
              searchInput.style.cssText = `
                  width: 100%;
                  padding: 4px 8px;
                  border: 1px solid #ddd;
                  border-radius: 4px;
                  font-size: 12px;
                  margin-top: 4px;
                  box-sizing: border-box;
              `;
              
              // Clear header content and add search input
              unitCodeHeader.innerHTML = '';
              unitCodeHeader.appendChild(document.createTextNode(originalText));
              unitCodeHeader.appendChild(document.createElement('br'));
              unitCodeHeader.appendChild(searchInput);
              
              // Add search functionality
              searchInput.addEventListener('input', function() {
                  const searchTerm = this.value.toLowerCase().trim();
                  const tableBody = document.querySelector('#unitsTable tbody');
                  
                  if (!tableBody) return;
                  
                  const rows = tableBody.querySelectorAll('tr');
                  
                  rows.forEach(row => {
                      const unitCodeCell = row.cells[1]; // Unit Code is the second column (index 1)
                      if (unitCodeCell) {
                          const unitCode = unitCodeCell.textContent.toLowerCase();
                          if (searchTerm === '' || unitCode.includes(searchTerm)) {
                              row.style.display = '';
                          } else {
                              row.style.display = 'none';
                          }
                      }
                  });
                  
                  // Update row count display if needed
                  updateVisibleRowCount();
              });
              
              // Add clear button functionality on escape key
              searchInput.addEventListener('keydown', function(e) {
                  if (e.key === 'Escape') {
                      this.value = '';
                      this.dispatchEvent(new Event('input'));
                  }
              });
          }
          
          function updateVisibleRowCount() {
              // Optional: Add functionality to show count of visible rows
              const tableBody = document.querySelector('#unitsTable tbody');
              if (tableBody) {
                  const visibleRows = tableBody.querySelectorAll('tr:not([style*="display: none"])');
              }
          }
          
          // Also apply search when table is updated by dashboard
          const originalUpdateDataTable = window.dashboard?.updateDataTable;
          if (originalUpdateDataTable) {
              window.dashboard.updateDataTable = function(units) {
                  originalUpdateDataTable.call(this, units);
                  
                  // Re-apply search filter after table update
                  const searchInput = document.querySelector('#unitsTable th:nth-child(2) input');
                  if (searchInput && searchInput.value) {
                      searchInput.dispatchEvent(new Event('input'));
                  }
              };
          }
      });
    </script>
    
  
    {% endblock %}
