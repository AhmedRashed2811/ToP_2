{% extends base_template %}
{% block title %}Market Unit Charts{% endblock %}
{% load static %}
{% block content %}

<style>

    @media (min-width: 1200px) {
        .container, .container-lg, .container-md, .container-sm, .container-xl {
            max-width: 100%;
        }
    }

    @media (min-width: 576px) {
        .container, .container-sm {
            max-width: 100%;
        }
    }

    .market-charts-container {
        max-width: 100%;
        margin: 0 auto;
        padding: 20px;
    }
    .page-header {
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 2px solid #e9ecef;
        padding-bottom: 20px;
    }
    .page-header h1 {
        color: #2c3e50;
        margin-bottom: 10px;
        font-weight: 600;
    }
    .subtitle {
        color: #6c757d;
        font-size: 1.1em;
    }
    .filters-section {
        background: #f8f9fa;
        padding: 25px;
        border-radius: 10px;
        margin-bottom: 30px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }
    .filters-form {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        align-items: end;
    }
    .filter-group {
        flex: 1;
        min-width: 200px;
    }
    .filter-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: #495057;
    }
    .filter-group select {
        width: 100%;
        padding: 10px 15px;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        background: white url('image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="%23333" d="M1,3 L6,8 L11,3"/></svg>') no-repeat right 15px center;
        background-size: 12px;
        font-size: 14px;
        appearance: none;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .filter-group select:focus {
        outline: none;
        border-color: #007bff;
        box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
    }
    .filter-actions {
        display: flex;
        gap: 10px;
        align-self: end;
    }
    .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
    }
    .btn-primary {
        background: #007bff;
        color: white;
    }
    .btn-primary:hover {
        background: #0056b3;
        transform: translateY(-1px);
    }
    .btn-secondary {
        background: #6c757d;
        color: white;
    }
    .btn-secondary:hover {
        background: #545b62;
    }
    .charts-section {
        display: flex;
        flex-direction: column;
        gap: 40px;
    }
    .chart-container {
        background: white;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 2px 15px rgba(0,0,0,0.1);
    }
    .chart-container h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        font-weight: 500;
        border-left: 4px solid #007bff;
        padding-left: 15px;
    }
    .chart-wrapper {
        overflow-x: auto;
        overflow-y: visible;
        border: 1px solid #e9ecef;
        border-radius: 5px;
        background: #fafafa;
        /* Increased width and height */
        width: 100%;
        max-width: 7700px; /* Slightly larger than canvas for padding/borders */
        height: 800px; /* Slightly increased height */
        position: relative;
        margin: 0 auto; /* Center if container is wider */
    }
    /* Custom styles for hierarchical labels - moved to top */
    .hierarchical-labels {
        position: absolute;
        top: 0;
        left: 72px;
        right: 0;
        /* Increased height */
        height: 140px;
        background: white;
        border-bottom: 2px solid #999999;
        z-index: 10;
    }
    .label-level {
        height: 35px; /* Increased height */
        border-bottom: 2px solid #999999;
        position: relative;
        font-size: 13px; /* Slightly larger font */
        line-height: 35px; /* Match height */
    }
    .label-level:last-child {
        border-bottom: 2px solid #999999;
    }
    .label-group {
        position: absolute;
        height: 100%;
        border-right: 2px solid #999999;
        text-align: center;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        padding: 0 10px; /* Increased padding */
        box-sizing: border-box;
        background-color: inherit;
        display: flex;
        align-items: center;
        justify-content: center;
        
    }
    /* Ensure all levels have a background color */
    .label-level-0 { background-color: #f8f9fa !important; font-weight: bold; }
    .label-level-1 { background-color: #e9ecef !important; }
    .label-level-2 { background-color: #dee2e6 !important; }
    .label-level-3 { background-color: #ced4da !important; }
    /* Styles for the value boxes */
    .candlestick-value-box {
        position: absolute;
        background-color: white;
        color: black;
        border: 1px solid #666666;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px; /* Slightly larger font */
        font-weight: bold;
        white-space: nowrap;
        pointer-events: none;
        /* Adjusted size */
        width: 60px;
        height: 20px;
        margin-left: -30px; /* Half of width */
        margin-top: -10px; /* Half of height */
        z-index: 5;
        padding: 2px;
        box-sizing: border-box;
    }
    .candlestick-value-box.avg {
        background-color: black;
        color: white;
        border: 1px solid #333333;
    }
    @media (max-width: 768px) {
        .filters-form {
            flex-direction: column;
        }
        .filter-group {
            min-width: 100%;
        }
        .filter-actions {
            width: 100%;
            justify-content: center;
        }
    }

    /* Header Container Styles */
.header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding: 20px;
    background: linear-gradient(135deg, #f97316, #fb923c);
    color: white;
    border-radius: 16px;
    box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
    position: relative;
    overflow: hidden;
  }
  
  .header-container::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    transform: translate(50px, -50px);
  }
  
  .header-buttons {
    display: flex;
    gap: 15px;
    position: relative;
    z-index: 1;
  }
  
  /* Base Button Styles */
  .btn {
    padding: 12px 20px;
    border-radius: 10px;
    border: none;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    text-decoration: none;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
    position: relative;
    overflow: hidden;
  }
  
  .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
  }
  
  .btn:hover::before {
    left: 100%;
  }
  
  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1);
  }
  
  /* Specific Button Styles */
  .report-button {
    background: linear-gradient(135deg, #764ba2, #667eea);
    color: white;
  }
  
  .report-button:hover {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
  }
  
  .secondary-button {
    background: linear-gradient(135deg, #6c757d, #5a6268);
    color: white;
  }
  
  .secondary-button:hover {
    background: linear-gradient(135deg, #5a6268, #6c757d);
    color: white;
  }
  
  .third-button {
    background: linear-gradient(135deg, #10b981, #0d9f6e);
    color: white;
  }
  
  .third-button:hover {
    background: linear-gradient(135deg, #0d9f6e, #10b981);
    color: white;
  }

  .forth-button {
    background: linear-gradient(135deg, #ef4444, #f87171); /* red-500 â†’ red-400 */
    color: white;
  }
  
  .forth-button:hover {
    background: linear-gradient(135deg, #f87171, #ef4444); /* reverse gradient on hover */
    color: white;
  }
  
  
  /* Mobile Responsiveness */
  @media (max-width: 768px) {
    .header-container {
      flex-direction: column;
      align-items: center;
      gap: 20px;
      text-align: center;
      padding: 25px 20px;
    }
    
    .header-buttons {
      width: 100%;
      flex-direction: column;
      gap: 12px;
    }
    
    .btn {
      width: 100%;
      justify-content: center;
      padding: 14px 20px;
    }
    
    .header-container::before {
      width: 150px;
      height: 150px;
      transform: translate(40px, -40px);
    }
  }
  
  @media (max-width: 480px) {
    .header-container {
      padding: 20px 15px;
    }
    
    .btn {
      font-size: 0.85rem;
      padding: 12px 16px;
    }
  }

</style>
<div class="market-charts-container">

    <div class="header-container">
        <div style="display: flex; align-items: center; gap: 18px;">
            <img src="{% static 'images/Screenshot 2025-12-15 170518.png' %}" alt="Your Company Logo"
                class="company-logo"
                style="height: 100px; max-width: 218px; border-radius: 10px; box-shadow: 0 1px 8px rgba(0,0,0,0.08);" />
        </div>
        <div class="header-buttons">
            <a href="{% url 'market_research_report' %}" class="btn report-button">
                <i class="fas fa-file-alt"></i>
                Report View
            </a>
            <a href="{% url 'market_explorer' %}" class="btn secondary-button">
                <i class="fas fa-map-marked-alt"></i>
                Map View
            </a>
            <a href="{% url 'market_dashboard' %}" class="btn third-button">
                <i class="fas fa-chart-bar"></i>
                Market Analysis
            </a>
            <a href="{% url 'market_charts_view' %}?location=6th+of+October&asset_type=&unit_type=" class="btn forth-button">
                <i class="fas fa-chart-line"></i>
                Units Analysis
            </a>            
        </div>
    </div>
    <!-- Filters -->
    <div class="filters-section">
        <form method="GET" class="filters-form">
            <div class="filter-group">
                <label for="location">Location:</label>
                <select name="location" id="location">
                    <option value="">All Locations</option>
                    {% for loc in locations %}
                        <option value="{{ loc }}" {% if loc == selected_locations.0 %}selected{% endif %}>{{ loc }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="filter-group">
                <label for="asset_type">Asset Type:</label>
                <select name="asset_type" id="asset_type">
                     <option value="">All Asset Types</option>
                    {% for at in asset_types %}
                        <option value="{{ at }}" {% if at == selected_asset_types.0 %}selected{% endif %}>{{ at }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="filter-group">
                <label for="unit_type">Unit Type:</label>
                <select name="unit_type" id="unit_type">
                     <option value="">All Unit Types</option>
                    {% for ut in unit_types %}
                        <option value="{{ ut }}" {% if ut == selected_unit_types.0 %}selected{% endif %}>{{ ut }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="filter-actions">
                <button type="submit" class="btn btn-primary">Apply Filters</button>
                <button type="button" class="btn btn-secondary" onclick="clearFilters()">Clear All</button>
            </div>
        </form>
    </div>
    <!-- Chart Containers -->
    <div class="charts-section">
        <div class="chart-container">
            <h2>Unit Price Range</h2>
            <div class="chart-wrapper">
                <div class="hierarchical-labels" id="priceLabels"></div>
                <!-- Increased canvas width -->
                <canvas id="priceChart" width="7500" height="660"></canvas>
            </div>
        </div>
        <div class="chart-container">
            <h2>Built-Up Area (BUA) Range</h2>
            <div class="chart-wrapper">
                <div class="hierarchical-labels" id="buaLabels"></div>
                <!-- Increased canvas width -->
                <canvas id="buaChart" width="7500" height="660"></canvas>
            </div>
        </div>
        <div class="chart-container">
            <h2>Price per Square Meter (PSM) Range</h2>
            <div class="chart-wrapper">
                <div class="hierarchical-labels" id="psmLabels"></div>
                <!-- Increased canvas width -->
                <canvas id="psmChart" width="7500" height="660"></canvas>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    // Utility function for formatting numbers
    function formatNumber(num) {
        if (num === null || num === undefined) return 'N/A';
        if (Math.abs(num) < 1) {
            if (num !== 0) {
                return num.toFixed(2);
            } else {
                return '0';
            }
        }
        if (num >= 1000000) {
            const millions = num / 1000000;
            return (Math.abs(millions) % 1 === 0 ? millions.toFixed(0) : millions.toFixed(1)) + 'M';
        }
        if (num >= 1000) {
            const thousands = num / 1000;
            return (Math.abs(thousands) % 1 === 0 ? thousands.toFixed(0) : thousands.toFixed(1)) + 'K';
        }
        return Math.round(num).toLocaleString();
    }
    // Enhanced function to flatten hierarchical data and create label structure
    function flattenChartDataWithHierarchy(hierarchicalData) {
        const flatLabels = [];
        const dataPoints = [];
        const labelHierarchy = {
            level0: [], // Finishing Specs
            level1: [], // Developer
            level2: [], // Project
            level3: []  // Payment Years
        };
        let currentIndex = 0;
        function processLevel(items, depth, parentInfo = {}) {
            if (!Array.isArray(items)) {
                console.error("Expected array for items, got:", items);
                return;
            }
            items.forEach(item => {
                if (!item || typeof item !== 'object') {
                    console.warn("Skipping invalid item:", item);
                    return;
                }
                const label = item.label || `Unnamed Node`;
                if (item.children && Array.isArray(item.children) && item.children.length > 0) {
                    // This is a group node
                    const startIndex = currentIndex;
                    // Process children first to know the span
                    const childrenCount = countLeafNodes(item.children);
                    // Add hierarchy info for this level
                    const hierarchyInfo = {
                        label: label,
                        startIndex: startIndex,
                        span: childrenCount,
                        level: depth
                    };
                    // Store in appropriate level
                    labelHierarchy[`level${depth}`].push(hierarchyInfo);
                    // Recurse into children with updated parent info
                    const newParentInfo = { ...parentInfo };
                    newParentInfo[`level${depth}`] = label;
                    processLevel(item.children, depth + 1, newParentInfo);
                } else {
                    // This is a leaf node (Payment Years)
                    flatLabels.push(label);
                    if (item.min !== undefined && item.avg !== undefined && item.max !== undefined) {
                        dataPoints.push({
                            min: item.min,
                            avg: item.avg,
                            max: item.max
                        });
                    } else {
                        dataPoints.push(null);
                    }
                    // Add leaf node to level 3
                    labelHierarchy.level3.push({
                        label: label,
                        startIndex: currentIndex,
                        span: 1,
                        level: 3,
                        parentInfo: parentInfo
                    });
                    currentIndex++;
                }
            });
        }
        function countLeafNodes(items) {
            let count = 0;
            items.forEach(item => {
                if (item.children && Array.isArray(item.children) && item.children.length > 0) {
                    count += countLeafNodes(item.children);
                } else {
                    count++;
                }
            });
            return count;
        }
        processLevel(hierarchicalData, 0);
        return {
            labels: flatLabels,
            dataPoints: dataPoints,
            labelHierarchy: labelHierarchy
        };
    }
    // Function to create hierarchical label display
    function createHierarchicalLabels(containerId, labelHierarchy, chartWidth) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';
        // Calculate the width per data point
        const totalDataPoints = labelHierarchy.level3.length;
        // Use the passed chartWidth for calculation
        const widthPerPoint = chartWidth / totalDataPoints;
        // Create 4 levels of labels
        for (let level = 0; level < 4; level++) {
            const levelDiv = document.createElement('div');
            levelDiv.className = `label-level label-level-${level}`;
            const levelData = labelHierarchy[`level${level}`] || [];
            levelData.forEach(item => {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'label-group';
                labelDiv.textContent = item.label;
                labelDiv.style.left = (item.startIndex * widthPerPoint) + 'px';
                labelDiv.style.width = (item.span * widthPerPoint) + 'px';
                labelDiv.title = item.label; // Tooltip for long labels
                levelDiv.appendChild(labelDiv);
            });
            container.appendChild(levelDiv);
        }
    }
    function renderChart(canvasId, chartData, chartTitle) {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        const chartWidth = canvas.width; // Get the actual canvas width
        const chartHeight = canvas.height;

        // Check if we have data
        const hasData = chartData.dataPoints.some(point => point !== null);
        if (!hasData) {
            ctx.clearRect(0, 0, chartWidth, chartHeight);
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillStyle = "#6c757d";
            ctx.fillText("No data available for selected filters", chartWidth / 2, chartHeight / 2);
            return;
        }
        // Prepare data for Chart.js
        const avgValues = chartData.dataPoints.map(point => point ? point.avg : NaN);
        // Calculate y-axis range
        let suggestedYMax = null;
        let suggestedYMin = null;
        const allValues = chartData.dataPoints.flatMap(p => p ? [p.min, p.avg, p.max] : []);
        if (allValues.length > 0) {
            const dataMax = Math.max(...allValues);
            const dataMin = Math.min(...allValues);
            const range = dataMax - dataMin;
            // Reduce padding below the chart area
            suggestedYMax = dataMax + range * 0.05;
            suggestedYMin = Math.max(0, dataMin - range * 0.02);
        }
        // Create the chart
        const chart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: chartData.labels,
                datasets: [
                    {
                        label: '',
                        data: chartData.dataPoints.map(p => p ? p.max : null),
                        backgroundColor: 'transparent',
                        borderColor: 'transparent',
                        pointRadius: 0,
                        pointHoverRadius: 0,
                    },
                    {
                        label: '',
                        data: avgValues,
                        type: 'line',
                        fill: false,
                        borderColor: 'transparent',
                        backgroundColor: 'transparent',
                        borderWidth: 0,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        showLine: false,
                        yAxisID: 'y',
                    }
                ]
            },
            options: {
                responsive: false, // Important: Keep false for fixed size
                maintainAspectRatio: false, // Important: Keep false for fixed size
                animation: false,
                layout: {
                    padding: {
                        top: 140, // Increased to match new label height
                        bottom: 5
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: suggestedYMin,
                        max: suggestedYMax,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    },
                    x: {
                        display: false,
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            padding: 20,
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.datasetIndex !== 0) return null;
                                const dataIndex = context.dataIndex;
                                const rawDataPoint = chartData.dataPoints[dataIndex];
                                if (!rawDataPoint) return 'No data';
                                return [
                                    `Min: ${formatNumber(rawDataPoint.min)}`,
                                    `Avg: ${formatNumber(rawDataPoint.avg)}`,
                                    `Max: ${formatNumber(rawDataPoint.max)}`
                                ];
                            }
                        }
                    }
                },
                onHover: (event, activeElements) => {
                    event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                }
            },
            plugins: [{
                id: 'customRangeRenderer',
                afterDatasetsDraw: function(chart) {
                    const ctx = chart.ctx;
                    const meta = chart.getDatasetMeta(0);
                    const chartArea = chart.chartArea;
                    const yScale = chart.scales.y;
                    // Use the actual canvas width for calculation
                    const widthPerPoint = chartWidth / chartData.labels.length;
                    chartData.dataPoints.forEach((dataPoint, index) => {
                        if (!dataPoint || !meta.data[index]) return;
                        const x = meta.data[index].x;
                        const minY = yScale.getPixelForValue(dataPoint.min);
                        const maxY = yScale.getPixelForValue(dataPoint.max);
                        const avgY = yScale.getPixelForValue(dataPoint.avg);
                        ctx.save();
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, minY);
                        ctx.lineTo(x, maxY);
                        ctx.stroke();
                        ctx.restore();
                        // Use the new box dimensions and offsets
                        const boxOffsetX = 0; // Centered now with margin-left
                        const boxOffsetY = 0; // Centered now with margin-top
                        const minBox = document.createElement('div');
                        minBox.className = 'candlestick-value-box';
                        minBox.textContent = formatNumber(dataPoint.min);
                        minBox.style.left = (x + boxOffsetX) + 'px';
                        minBox.style.top = (minY + boxOffsetY) + 'px';
                        ctx.canvas.parentNode.appendChild(minBox);
                        const maxBox = document.createElement('div');
                        maxBox.className = 'candlestick-value-box';
                        maxBox.textContent = formatNumber(dataPoint.max);
                        maxBox.style.left = (x + boxOffsetX) + 'px';
                        maxBox.style.top = (maxY + boxOffsetY) + 'px';
                        ctx.canvas.parentNode.appendChild(maxBox);
                        const avgBox = document.createElement('div');
                        avgBox.className = 'candlestick-value-box avg';
                        avgBox.textContent = formatNumber(dataPoint.avg);
                        avgBox.style.left = (x + boxOffsetX) + 'px';
                        avgBox.style.top = (avgY + boxOffsetY) + 'px';
                        ctx.canvas.parentNode.appendChild(avgBox);
                    });
                }
            }]
        });
        // Create hierarchical labels, passing the actual canvas width
        const labelsContainerId = canvasId.replace('Chart', 'Labels');
        createHierarchicalLabels(labelsContainerId, chartData.labelHierarchy, chartWidth);
        return chart;
    }
    // Clear filters function
    function clearFilters() {
        document.getElementById('location').value = '';
        document.getElementById('asset_type').value = '';
        document.getElementById('unit_type').value = '';
        document.querySelector('.filters-form').submit();
    }
    // Initialize charts when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Get data from Django context
        const priceData = {{ price_data|safe }};
        const buaData = {{ bua_data|safe }};
        const psmData = {{ psm_data|safe }};
        // Process and render charts
        if (priceData && priceData.length > 0) {
            const processedPriceData = flattenChartDataWithHierarchy(priceData);
            renderChart('priceChart', processedPriceData, 'Unit Price');
        }
        if (buaData && buaData.length > 0) {
            const processedBuaData = flattenChartDataWithHierarchy(buaData);
            renderChart('buaChart', processedBuaData, 'Built-Up Area (BUA)');
        }
        if (psmData && psmData.length > 0) {
            const processedPsmData = flattenChartDataWithHierarchy(psmData);
            renderChart('psmChart', processedPsmData, 'Price per Square Meter (PSM)');
        }
    });
</script>
{% endblock %}