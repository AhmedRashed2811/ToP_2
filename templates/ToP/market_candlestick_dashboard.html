{% extends base_template %}

{% block title %}Market Analysis{% endblock %}

{% load static %}

{% block content %}

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<style>
    /* REQUIRED (must be at top of style tag) */
    .container {
        margin-top: 80px;
        padding: 0;
    }
    
    @media (min-width: 1400px) {
        .container, .container-lg, .container-md, .container-sm, .container-xl, .container-xxl { max-width: 100%; }
    }
    
    @media (min-width: 576px) {
        .container, .container-sm { max-width: 100%; }
    }

    :root {
        --bg: #f6f7fb;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --border: rgba(2,6,23,.10);
        --shadow: 0 14px 40px rgba(2, 6, 23, .08);
        --shadow-sm: 0 8px 22px rgba(2, 6, 23, .06);
        --radius: 18px;
        --accent: #2563eb;
        --ring: 0 0 0 4px rgba(37,99,235,.14);
        
        /* FIXED: Adjusted values for proper positioning */
        --labelsH: 144px;
        --yGutter: 60px;
        --chartTopPadding: 40px;
        --chartBottomPadding: 60px;
        --rightPadding: 30px; /* NEW: Right padding for last cell */
    }

    body { 
        background: var(--bg); 
        font-family: "Times New Roman", Times, serif;
    }

    .page { 
        padding: 16px 16px 26px; 
    }

    /* Header - unchanged */
    .header-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 14px;
        padding: 16px 18px;
        background: linear-gradient(135deg, #f97316, #fb923c);
        color: white;
        border-radius: 16px;
        box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        position: relative;
        overflow: hidden;
        gap: 14px;
    }
    
    .header-container::before {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        width: 220px;
        height: 220px;
        background: rgba(255, 255, 255, 0.10);
        border-radius: 50%;
        transform: translate(60px, -60px);
    }
    
    .header-left {
        display: flex;
        align-items: center;
        gap: 14px;
        position: relative;
        z-index: 1;
        min-width: 260px;
    }
    
    .company-logo {
        height: 78px;
        max-width: 240px;
        border-radius: 12px;
        box-shadow: 0 1px 10px rgba(0,0,0,0.12);
        background: rgba(255,255,255,.15);
        padding: 6px;
        object-fit: contain;
    }
    
    .header-buttons {
        display: flex;
        gap: 10px;
        position: relative;
        z-index: 1;
        flex-wrap: wrap;
        justify-content: flex-end;
    }
    
    .btnx {
        padding: 10px 14px;
        border-radius: 12px;
        border: none;
        font-size: 0.86rem;
        font-weight: 800;
        cursor: pointer;
        transition: all .22s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        text-decoration: none;
        box-shadow: 0 6px 10px -6px rgb(0 0 0 / 0.25);
        position: relative;
        overflow: hidden;
        color: white;
        user-select: none;
        white-space: nowrap;
        font-family: "Times New Roman", Times, serif;
    }
    
    .btnx::before {
        content: '';
        position: absolute;
        inset: 0;
        transform: translateX(-110%);
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.22), transparent);
        transition: transform .55s ease;
    }
    
    .btnx:hover::before { transform: translateX(110%); }
    .btnx:hover { transform: translateY(-2px); box-shadow: 0 18px 24px -14px rgba(0,0,0,.30); }
    
    .btn-report { background: linear-gradient(135deg, #764ba2, #667eea); }
    .btn-map { background: linear-gradient(135deg, #6c757d, #5a6268); }
    .btn-dash { background: linear-gradient(135deg, #10b981, #0d9f6e); }
    .btn-units { background: linear-gradient(135deg, #ef4444, #f87171); }

    @media (max-width: 900px) {
        .header-container { flex-direction: column; align-items: stretch; }
        .header-buttons { justify-content: center; }
        .btnx { width: 100%; justify-content: center; }
        .header-left { justify-content: center; min-width: auto; }
    }

    /* Panels */
    .panel {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow-sm);
        padding: 14px;
        margin-bottom: 14px;
    }
    
    .panel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .panel-head h3 {
        margin: 0;
        font-size: 13px;
        font-weight: 900;
        color: var(--text);
        letter-spacing: .2px;
        font-family: "Times New Roman", Times, serif;
    }
    
    .chip {
        font-size: 12px;
        color: var(--muted);
        border: 1px solid var(--border);
        background: #fff;
        padding: 6px 10px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
        font-family: "Times New Roman", Times, serif;
    }
    
    .chip b { color: var(--text); }

    /* Filters */
    .grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 12px; }
    .grid4 { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 12px; }
    
    @media (max-width: 1100px) {
        .grid { grid-template-columns: 1fr; }
        .grid4 { grid-template-columns: 1fr; }
    }
    
    .field {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }
    
    .field label {
        font-size: 12px;
        color: var(--muted);
        font-weight: 800;
        font-family: "Times New Roman", Times, serif;
    }
    
    .select {
        width: 100%;
        appearance: none;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 13px;
        color: var(--text);
        background: #fff;
        outline: none;
        transition: box-shadow .18s ease, border-color .18s ease, opacity .18s ease;
        cursor: pointer;
        font-family: "Times New Roman", Times, serif;
    }
    
    .select:focus { border-color: rgba(37,99,235,.35); box-shadow: var(--ring); }
    .select:disabled { opacity: .55; cursor: not-allowed; background: #f8fafc; }
    
    .actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        align-items: center;
        flex-wrap: wrap;
        margin-top: 10px;
    }
    
    .btn-ghost {
        border: 1px solid var(--border);
        background: #fff;
        color: var(--text);
        font-weight: 900;
        padding: 10px 12px;
        border-radius: 14px;
        cursor: pointer;
        transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
        font-family: "Times New Roman", Times, serif;
    }
    
    .btn-ghost:hover { transform: translateY(-1px); box-shadow: var(--shadow-sm); background: #fbfbfd; }

    /* States */
    .empty {
        border: 1px dashed rgba(2,6,23,.18);
        background: rgba(255,255,255,.70);
        border-radius: var(--radius);
        padding: 14px;
        color: var(--muted);
        font-size: 13px;
        margin-bottom: 14px;
        font-family: "Times New Roman", Times, serif;
    }
    
    .loading {
        display: none;
        gap: 10px;
        align-items: center;
        color: var(--muted);
        font-size: 12px;
        margin-top: 10px;
        font-family: "Times New Roman", Times, serif;
    }
    
    .loading.show { display: flex; }
    
    .spinner {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        border: 2px solid rgba(2,6,23,.12);
        border-top-color: rgba(37,99,235,.7);
        animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }

    /* CHARTS SECTION - UPDATED */
    .charts-section {
        display: flex;
        flex-direction: column;
        gap: 14px;
    }
    
    .chart-container {
        background: var(--card);
        padding: 14px;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        border: 1px solid var(--border);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        height: 650px;
    }
    
    .chart-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
        flex-shrink: 0;
    }
    
    .chart-header h2 {
        margin: 0;
        font-size: 13px;
        font-weight: 900;
        color: var(--text);
        border-left: 4px solid var(--accent);
        padding-left: 12px;
        letter-spacing: .2px;
        font-family: "Times New Roman", Times, serif;
    }
    
    .crumb {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
        border-left: 3px solid rgba(37,99,235,.25);
        padding-left: 10px;
        max-width: 860px;
        font-family: "Times New Roman", Times, serif;
    }

    /* CHART WRAPPER */
    .chart-wrapper {
        flex: 1;
        overflow: auto;
        border: 1px solid rgba(2,6,23,.10);
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(2,6,23,.02), transparent);
        position: relative;
        min-height: 100%;
    }

    /* SCROLL CONTAINER - UPDATED */
    .chart-scroll {
        position: relative;
        min-width: 100%;
        min-height: 100%;
        /* Add right padding for the last cell */
        padding-right: var(--rightPadding);
    }

    /* HIERARCHICAL LABELS - UPDATED for right padding */
    .hierarchical-labels {
        position: absolute;
        top: 0;
        left: var(--yGutter);
        height: var(--labelsH);
        /* Account for right padding */
        width: calc(100% - var(--yGutter) - var(--rightPadding));
        background: rgba(255,255,255,.95);
        border-bottom: 2px solid rgba(2,6,23,.35);
        z-index: 10;
        user-select: none;
        pointer-events: none;
        backdrop-filter: blur(8px);
        overflow: hidden;
    }

    .label-level {
        height: calc(var(--labelsH) / 4);
        border-bottom: 1px solid rgba(2,6,23,.30);
        position: relative;
        font-size: 12px;
        overflow: hidden;
        display: flex;
        align-items: center;
        font-family: "Times New Roman", Times, serif;
    }
    
    .label-level:last-child { border-bottom: 2px solid rgba(2,6,23,.35); }
    
    .label-group {
        position: absolute;
        height: 100%;
        border-right: 1px solid rgba(2,6,23,.30);
        text-align: center;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        padding: 0 5px;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        color: rgba(2,6,23,.82);
        pointer-events: none;
        font-family: "Times New Roman", Times, serif;
        line-height: 1.2;
    }
    
    .label-level-0 .label-group { background: #f8fafc; }
    .label-level-1 .label-group { background: #eef2f7; }
    .label-level-2 .label-group { background: #e7edf5; }
    .label-level-3 .label-group { background: #dfe7f2; }

    /* CANVAS POSITIONING - UPDATED */
    canvas {
        display: block;
        position: absolute;
        top: calc(var(--labelsH) + var(--chartTopPadding));
        left: 0;
        /* Account for right padding */
        width: calc(100% - var(--rightPadding));
        height: calc(100% - var(--labelsH) - var(--chartTopPadding) - var(--chartBottomPadding));
    }

    /* VALUE BOXES - UPDATED for centered positioning */
    .candlestick-value-box {
        position: absolute;
        background: white;
        color: rgba(2,6,23,.92);
        border: 1px solid rgba(2,6,23,.45);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 900;
        white-space: nowrap;
        pointer-events: none;
        width: 66px;
        height: 22px;
        margin-left: -33px;
        margin-top: -11px;
        z-index: 15; /* Increased z-index */
        padding: 2px 4px;
        box-sizing: border-box;
        border-radius: 8px;
        box-shadow: 0 10px 18px rgba(2,6,23,.10);
        transform: translate(-50%, -50%);
        font-family: "Times New Roman", Times, serif;
    }
    
    .candlestick-value-box.avg {
        background: rgba(2,6,23,.92);
        color: #fff;
        border: 1px solid rgba(2,6,23,.92);
    }

    /* NEW: Custom Tooltip Styles */
    .custom-tooltip {
        position: absolute;
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid rgba(2,6,23,.25);
        border-radius: 12px;
        padding: 10px;
        z-index: 20;
        pointer-events: none;
        box-shadow: 0 12px 28px rgba(2,6,23,.15);
        min-width: 180px;
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-family: "Times New Roman", Times, serif;
    }

    .tooltip-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(2,6,23,.08);
    }

    .tooltip-item:last-child {
        border-bottom: none;
    }

    .tooltip-label {
        font-size: 10px;
        color: rgba(2,6,23,.65);
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .tooltip-value {
        font-size: 11px;
        color: rgba(2,6,23,.9);
        font-weight: 900;
        padding: 4px 0;
        border-bottom: 1px solid rgba(2,6,23,.08);
    }

    .tooltip-metric {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: rgba(2,6,23,.9);
        font-weight: 900;
        margin-top: 4px;
    }

    .custom-tooltip .tooltip-value:nth-child(4){
        border-bottom: none; /* last header value */
    }


    /* Animations */
    .anim-swap { animation: fadeUp .24s ease both; }
    
    @keyframes fadeUp {
        from { opacity: 0; transform: translateY(7px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .hint {
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
        display: flex;
        gap: 8px;
        align-items: flex-start;
        line-height: 1.45;
        font-family: "Times New Roman", Times, serif;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .chart-container {
            height: 500px;
        }
        
        :root {
            --labelsH: 120px;
            --yGutter: 50px;
            --chartTopPadding: 30px;
            --chartBottomPadding: 50px;
            --rightPadding: 20px;
        }
    }
    
    @media (max-width: 480px) {
        .chart-container {
            height: 100%;
        }
        
        :root {
            --labelsH: 100px;
            --yGutter: 40px;
            --chartTopPadding: 20px;
            --chartBottomPadding: 40px;
            --rightPadding: 15px;
        }
    }
</style>

<div class="container">
  <div class="page">

    <!-- HEADER -->
    <div class="header-container">
      <div class="header-left">
        <img src="{% static 'images/Screenshot 2025-12-15 170518.png' %}" alt="Logo" class="company-logo" />
      </div>

      <div class="header-buttons">
        <a href="{% url 'market_research_report' %}" class="btnx btn-report">Report View</a>
        <a href="{% url 'market_explorer' %}" class="btnx btn-map">Map View</a>
        <a href="{% url 'market_charts_view' %}?location=6th+of+October&asset_type=&unit_type=" class="btnx btn-units">Market Analysis</a>
      </div>
    </div>

    <!-- GLOBAL FILTERS (AJAX LOAD) -->
    <div class="panel" id="globalPanel">
      <div class="panel-head">
        <h3>Global Filters (loads data)</h3>
        <span class="chip" id="loadChip">No data loaded</span>
      </div>

      <div class="grid">
        <div class="field">
          <label for="gf_location">Location</label>
          <select id="gf_location" class="select">
            <option value="">â€” Choose â€”</option>
            {% for loc in locations %}
              <option value="{{ loc|escape }}">{{ loc }}</option>
            {% endfor %}
          </select>
        </div>

        <div class="field">
          <label for="gf_asset_type">Asset Type</label>
          <select id="gf_asset_type" class="select">
            <option value="">â€” Choose â€”</option>
            {% for at in asset_types %}
              <option value="{{ at|escape }}">{{ at }}</option>
            {% endfor %}
          </select>
        </div>

        <div class="field">
          <label for="gf_unit_type">Unit Type</label>
          <select id="gf_unit_type" class="select">
            <option value="">â€” Choose â€”</option>
            {% for ut in unit_types %}
              <option value="{{ ut|escape }}">{{ ut }}</option>
            {% endfor %}
          </select>
        </div>
      </div>

      <div class="actions">
        <button class="btn-ghost" type="button" id="resetBtn">Reset</button>
      </div>

      <div class="loading" id="loadingRow">
        <div class="spinner"></div>
        <div>Loading rowsâ€¦</div>
      </div>

      <div class="hint">
        <span>ðŸ’¡</span>
        <span>No "Apply" button. Any change here triggers an AJAX load. Analysis starts only after at least one global filter is selected.</span>
      </div>
    </div>

    <!-- EMPTY STATE -->
    <div class="empty" id="emptyState">
      Select <b>Location</b> or <b>Asset Type</b> or <b>Unit Type</b> to load data and start analysis.
    </div>

    <!-- HIERARCHY FILTERS -->
    <div class="panel" id="hierPanel" style="display:none;">
      <div class="panel-head">
        <h3>Hierarchy Filters</h3>
      </div>

      <div class="grid4">
        <div class="field">
          <label for="hf_finishing">Finishing Specs</label>
          <select id="hf_finishing" class="select" disabled></select>
        </div>

        <div class="field">
          <label for="hf_developer">Developer</label>
          <select id="hf_developer" class="select" disabled></select>
        </div>

        <div class="field">
          <label for="hf_project">Project</label>
          <select id="hf_project" class="select" disabled></select>
        </div>

        <div class="field">
          <label for="hf_payment">Payment Years</label>
          <select id="hf_payment" class="select" disabled></select>
        </div>
      </div>

      <div class="hint">
        <span>âš¡</span>
        <span>Each level filters the next (dependent dropdowns). Changing any level re-renders all charts with animation.</span>
      </div>
    </div>

    <!-- CHARTS SECTION -->
    <div class="charts-section" id="chartsSection" style="display:none;">

      <!-- PRICE -->
      <div class="chart-container" id="priceContainer">
        <div class="chart-header">
          <div>
            <h2>Unit Price Range</h2>
            <div class="crumb" id="crumbPrice">â€”</div>
          </div>
          <span class="chip" id="rowsChipPrice">0 rows</span>
        </div>

        <div class="chart-wrapper" id="priceWrapper">
          <div class="chart-scroll" id="priceScroll">
            <div class="hierarchical-labels" id="priceLabels"></div>
            <canvas id="priceChart"></canvas>
          </div>
        </div>
      </div>

      <!-- BUA -->
      <div class="chart-container" id="buaContainer">
        <div class="chart-header">
          <div>
            <h2>Built-Up Area (BUA) Range</h2>
            <div class="crumb" id="crumbBUA">â€”</div>
          </div>
          <span class="chip" id="rowsChipBUA">0 rows</span>
        </div>

        <div class="chart-wrapper" id="buaWrapper">
          <div class="chart-scroll" id="buaScroll">
            <div class="hierarchical-labels" id="buaLabels"></div>
            <canvas id="buaChart"></canvas>
          </div>
        </div>
      </div>

      <!-- PSM -->
      <div class="chart-container" id="psmContainer">
        <div class="chart-header">
          <div>
            <h2>Price per Square Meter (PSM) Range</h2>
            <div class="crumb" id="crumbPSM">â€”</div>
          </div>
          <span class="chip" id="rowsChipPSM">0 rows</span>
        </div>

        <div class="chart-wrapper" id="psmWrapper">
          <div class="chart-scroll" id="psmScroll">
            <div class="hierarchical-labels" id="psmLabels"></div>
            <canvas id="psmChart"></canvas>
          </div>
        </div>
      </div>

    </div>

  </div>
</div>

<script>
(() => {
  const DATA_URL = "{% url 'market_units_analysis_data' %}";

  // Elements
  const gfLocation = document.getElementById("gf_location");
  const gfAsset = document.getElementById("gf_asset_type");
  const gfUnit = document.getElementById("gf_unit_type");
  const resetBtn = document.getElementById("resetBtn");

  const loadChip = document.getElementById("loadChip");
  const loadingRow = document.getElementById("loadingRow");
  const emptyState = document.getElementById("emptyState");

  const hierPanel = document.getElementById("hierPanel");
  const chartsSection = document.getElementById("chartsSection");

  const hfFinishing = document.getElementById("hf_finishing");
  const hfDeveloper = document.getElementById("hf_developer");
  const hfProject = document.getElementById("hf_project");
  const hfPayment = document.getElementById("hf_payment");

  const crumbPrice = document.getElementById("crumbPrice");
  const crumbBUA   = document.getElementById("crumbBUA");
  const crumbPSM   = document.getElementById("crumbPSM");

  const rowsChipPrice = document.getElementById("rowsChipPrice");
  const rowsChipBUA   = document.getElementById("rowsChipBUA");
  const rowsChipPSM   = document.getElementById("rowsChipPSM");

  let rawRows = [];
  let controller = null;

  const ALL = "__ALL__";
  const charts = { price:null, bua:null, psm:null };
  let customTooltip = null;

  // Helpers
  const norm = (v) => {
    if (v === null || v === undefined) return "Unknown";
    const s = String(v).trim();
    return s ? s : "Unknown";
  };
  
  const toNum = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  function formatNumber(num) {
    if (num === null || num === undefined || !Number.isFinite(num)) return 'N/A';
    const abs = Math.abs(num);
    if (abs < 1 && num !== 0) return num.toFixed(2);
    if (abs >= 1_000_000) {
      const m = num / 1_000_000;
      return (Math.abs(m) % 1 === 0 ? m.toFixed(0) : m.toFixed(1)) + 'M';
    }
    if (abs >= 1_000) {
      const k = num / 1_000;
      return (Math.abs(k) % 1 === 0 ? k.toFixed(0) : k.toFixed(1)) + 'K';
    }
    return Math.round(num).toLocaleString();
  }

  const uniqSorted = (arr) => Array.from(new Set(arr)).sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));

  function animate(el){
    el.classList.remove("anim-swap");
    void el.offsetWidth;
    el.classList.add("anim-swap");
  }

  function setOptions(selectEl, values, keepValue = ALL) {
    selectEl.innerHTML = "";
    const optAll = document.createElement("option");
    optAll.value = ALL;
    optAll.textContent = "All";
    selectEl.appendChild(optAll);

    values.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      selectEl.appendChild(opt);
    });

    const exists = Array.from(selectEl.options).some(o => o.value === keepValue);
    selectEl.value = exists ? keepValue : ALL;
  }

  function clearValueBoxes(scrollEl){
    scrollEl.querySelectorAll(".candlestick-value-box").forEach(n => n.remove());
    }

    function clearTooltip(){
    if (customTooltip) {
        customTooltip.remove();
        customTooltip = null;
    }
    }


  function selectionCrumb(){
    const show = (v) => (v === ALL ? "All" : v);
    return `Finishing: ${show(hfFinishing.value)}  â€¢  Developer: ${show(hfDeveloper.value)}  â€¢  Project: ${show(hfProject.value)}  â€¢  Payment: ${show(hfPayment.value)}`;
  }

  function filteredRowsByHierarchy(rows){
    const fin = hfFinishing.value;
    const dev = hfDeveloper.value;
    const proj = hfProject.value;
    const pay = hfPayment.value;

    return rows.filter(r => {
      if (fin !== ALL && norm(r.finishing_specs) !== fin) return false;
      if (dev !== ALL && norm(r.developer_name) !== dev) return false;
      if (proj !== ALL && norm(r.project_name) !== proj) return false;
      if (pay !== ALL && norm(r.payment_yrs) !== pay) return false;
      return true;
    });
  }

  function buildHierarchy(rows, metricField) {
    const root = new Map();
    rows.forEach(r => {
      const fin = norm(r.finishing_specs);
      const dev = norm(r.developer_name);
      const proj = norm(r.project_name);
      const pay = norm(r.payment_yrs);
      if (!root.has(fin)) root.set(fin, new Map());
      const devMap = root.get(fin);
      if (!devMap.has(dev)) devMap.set(dev, new Map());
      const projMap = devMap.get(dev);
      if (!projMap.has(proj)) projMap.set(proj, new Map());
      const payMap = projMap.get(proj);
      if (!payMap.has(pay)) payMap.set(pay, []);
      payMap.get(pay).push(r);
    });

    function stats(list){
      const nums = list.map(x => toNum(x[metricField])).filter(n => n !== null);
      if (!nums.length) return {min: null, avg: null, max: null};
      let min = nums[0], max = nums[0], sum = 0;
      for (const n of nums){
        if (n < min) min = n;
        if (n > max) max = n;
        sum += n;
      }
      return {min, avg: sum/nums.length, max};
    }

    const finKeys = Array.from(root.keys()).sort((a,b) => a.localeCompare(b));
    const out = [];

    for (const fin of finKeys){
      const devMap = root.get(fin);
      const devKeys = Array.from(devMap.keys()).sort((a,b) => a.localeCompare(b));
      const finNode = { label: fin, children: [], type: 'finishing' };
      for (const dev of devKeys){
        const projMap = devMap.get(dev);
        const projKeys = Array.from(projMap.keys()).sort((a,b) => a.localeCompare(b));
        const devNode = { label: dev, children: [], type: 'developer', parent: finNode };
        for (const proj of projKeys){
          const payMap = projMap.get(proj);
          const payKeys = Array.from(payMap.keys()).sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));
          const projNode = { label: proj, children: [], type: 'project', parent: devNode };
          for (const pay of payKeys){
            const s = stats(payMap.get(pay));
            const payNode = { 
              label: pay, min: s.min, avg: s.avg, max: s.max,
              type: 'payment', parent: projNode,
              hierarchy: { finishing: fin, developer: dev, project: proj, payment: pay }
            };
            projNode.children.push(payNode);
          }
          devNode.children.push(projNode);
        }
        finNode.children.push(devNode);
      }
      out.push(finNode);
    }
    return out;
  }

  function flattenWithHierarchy(tree, metricKey) {
    const flatLabels = [];
    const dataPoints = [];
    const labelHierarchy = { level0: [], level1: [], level2: [], level3: [] };
    const hierarchyInfo = [];
    let currentIndex = 0;

    function countLeaves(items){
      let c = 0;
      items.forEach(it => {
        if (it && it.children && it.children.length) c += countLeaves(it.children);
        else c++;
      });
      return c;
    }

    function walk(items, depth){
      if (!Array.isArray(items)) return;
      items.forEach(item => {
        if (!item || typeof item !== "object") return;
        const label = item.label ?? "Unnamed";
        const hasChildren = Array.isArray(item.children) && item.children.length > 0;
        if (hasChildren){
          const startIndex = currentIndex;
          const span = countLeaves(item.children);
          labelHierarchy[`level${depth}`].push({ label, startIndex, span, level: depth });
          walk(item.children, depth + 1);
        } else {
          flatLabels.push(label);
          const min = (item.min !== null && item.min !== undefined) ? Number(item.min) : null;
          const avg = (item.avg !== null && item.avg !== undefined) ? Number(item.avg) : null;
          const max = (item.max !== null && item.max !== undefined) ? Number(item.max) : null;
          const ok = Number.isFinite(min) && Number.isFinite(avg) && Number.isFinite(max);
          dataPoints.push(ok ? {min, avg, max} : null);
          hierarchyInfo.push({
            finishing: item.hierarchy?.finishing || "Unknown",
            developer: item.hierarchy?.developer || "Unknown",
            project: item.hierarchy?.project || "Unknown",
            payment: item.hierarchy?.payment || "Unknown"
          });
          labelHierarchy.level3.push({ label, startIndex: currentIndex, span: 1, level: 3 });
          currentIndex++;
        }
      });
    }

    walk(tree, 0);
    return { labels: flatLabels, dataPoints, labelHierarchy, hierarchyInfo };
  }

  function getHierarchyPath(hierarchyInfo, index) {
    if (!hierarchyInfo || !hierarchyInfo[index]) {
      return { finishing: "Unknown", developer: "Unknown", project: "Unknown", payment: "Unknown" };
    }
    return hierarchyInfo[index];
  }

  function buildHierLabels(labelsEl, labelHierarchy, chart, meta, barWidth) {
    labelsEl.innerHTML = "";
    const elements = meta.data || [];
    if (!elements.length) return;
    const style = getComputedStyle(document.documentElement);
    const yGutter = parseFloat(style.getPropertyValue('--yGutter').trim()) || 60;
    
    for (let level = 0; level < 4; level++) {
      const levelDiv = document.createElement("div");
      levelDiv.className = `label-level label-level-${level}`;
      (labelHierarchy[`level${level}`] || []).forEach(item => {
        const g = document.createElement("div");
        g.className = "label-group";
        g.textContent = item.label;
        g.title = item.label;
        const s = Math.max(0, item.startIndex);
        const e = Math.min(elements.length - 1, item.startIndex + item.span - 1);
        if (elements[s] && elements[e]) {
          const xS = elements[s].x;
          const xE = elements[e].x;
          const leftPos = (xS - (barWidth / 2)) - yGutter;
          const rightPos = (xE + (barWidth / 2)) - yGutter;
          const width = Math.max(0, rightPos - leftPos);
          g.style.left = `${leftPos}px`;
          g.style.width = `${width}px`;
        }
        levelDiv.appendChild(g);
      });
      labelsEl.appendChild(levelDiv);
    }
  }

    function showCustomTooltip(chart, index, hierarchyInfo, dataPoint, scrollContainer) {
    // 1) Remove old tooltip
    clearTooltip();

    // 2) Build tooltip content (values only)
    const hierarchy = getHierarchyPath(hierarchyInfo, index);

    customTooltip = document.createElement("div");
    customTooltip.className = "custom-tooltip";
    customTooltip.style.zIndex = "100";

    customTooltip.innerHTML = `
        <div class="tooltip-value">${hierarchy.finishing}</div>
        <div class="tooltip-value">${hierarchy.developer}</div>
        <div class="tooltip-value">${hierarchy.project}</div>
        <div class="tooltip-value">${hierarchy.payment}</div>

        <div class="tooltip-metric"><span>Min:</span><span>${formatNumber(dataPoint.min)}</span></div>
        <div class="tooltip-metric"><span>Avg:</span><span>${formatNumber(dataPoint.avg)}</span></div>
        <div class="tooltip-metric"><span>Max:</span><span>${formatNumber(dataPoint.max)}</span></div>
    `;

    // 3) Append to scroll container (so it can be measured)
    scrollContainer.appendChild(customTooltip);

    // 4) Resolve bar element
    const meta = chart.getDatasetMeta(0);
    const bar = meta.data[index];
    if (!bar) return;

    // 5) Get bounds
    const canvasRect = chart.canvas.getBoundingClientRect();
    const scrollRect = scrollContainer.getBoundingClientRect();

    // Bar X in viewport
    const barX_Viewport = canvasRect.left + bar.x;

    // Mid Y between min & max (in canvas coords)
    const yScale = chart.scales.y;
    const yMaxPx = yScale.getPixelForValue(dataPoint.max);
    const yMinPx = yScale.getPixelForValue(dataPoint.min);
    const yMidPx = (yMaxPx + yMinPx) / 2;

    // Mid Y in viewport
    const midY_Viewport = canvasRect.top + yMidPx;

    // 6) Measure real tooltip size
    const tipRect = customTooltip.getBoundingClientRect();
    const tooltipWidth = tipRect.width;
    const tooltipHeight = tipRect.height;

    // 7) Convert viewport coords -> scrollContainer coords
    let finalLeft = (barX_Viewport - scrollRect.left) - (tooltipWidth / 2);
    let finalTop  = (midY_Viewport - scrollRect.top) - (tooltipHeight / 2);

    // 8) Clamp to the visible wrapper viewport (no flip under min)
    const wrapper = scrollContainer.parentElement; // .chart-wrapper
    const pad = 10;

    // Vertical clamp within visible portion of wrapper
    const minTop = wrapper.scrollTop + pad;
    const maxTop = wrapper.scrollTop + wrapper.clientHeight - tooltipHeight - pad;
    if (maxTop >= minTop) {
        finalTop = Math.min(Math.max(finalTop, minTop), maxTop);
    } else {
        finalTop = minTop;
    }

    // Horizontal clamp within visible portion of wrapper
    const minLeft = wrapper.scrollLeft + pad;
    const maxLeft = wrapper.scrollLeft + wrapper.clientWidth - tooltipWidth - pad;
    if (maxLeft >= minLeft) {
        finalLeft = Math.min(Math.max(finalLeft, minLeft), maxLeft);
    } else {
        finalLeft = minLeft;
    }

    // 9) Apply final position
    customTooltip.style.left = `${finalLeft}px`;
    customTooltip.style.top  = `${finalTop}px`;
    }


  function renderRangeChart({canvasId, scrollId, labelsId, processed, title, metricKey}) {
    const canvas = document.getElementById(canvasId);
    const scrollEl = document.getElementById(scrollId);
    const labelsEl = document.getElementById(labelsId);
    const wrapper = scrollEl.parentElement;
    const ctx = canvas.getContext("2d");

    clearValueBoxes(scrollEl);
    clearTooltip();
    labelsEl.innerHTML = "";
    if (charts[metricKey]) { 
      charts[metricKey].destroy(); 
      charts[metricKey] = null; 
    }

    const leafCount = Math.max(1, processed.labels.length);
    let pxPerLeaf;
    if (leafCount === 1) pxPerLeaf = 300;
    else if (leafCount <= 15) pxPerLeaf = 170;
    else if (leafCount <= 35) pxPerLeaf = 135;
    else if (leafCount <= 70) pxPerLeaf = 110;
    else pxPerLeaf = 95;

    const wrapperWidth = wrapper.clientWidth + 50|| 1200;
    const wrapperHeight = wrapper.clientHeight || 400;
    const style = getComputedStyle(document.documentElement);
    const rightPadding = parseFloat(style.getPropertyValue('--rightPadding').trim()) || 30;
    const chartWidth = Math.max(wrapperWidth, leafCount * pxPerLeaf + rightPadding);
    const labelsH = parseFloat(style.getPropertyValue('--labelsH').trim()) || 144;
    const chartTopPadding = parseFloat(style.getPropertyValue('--chartTopPadding').trim()) || 40;
    const chartBottomPadding = parseFloat(style.getPropertyValue('--chartBottomPadding').trim()) || 60;
    const chartHeight = Math.max(300, wrapperHeight - labelsH - chartTopPadding - chartBottomPadding);
    const totalHeight = labelsH + chartTopPadding + chartHeight + chartBottomPadding;

    scrollEl.style.width = Number(chartWidth + 50) + "px";
    scrollEl.style.height = totalHeight + "px";
    canvas.width = chartWidth - rightPadding;
    canvas.height = chartHeight;
    canvas.style.top = `${labelsH + chartTopPadding}px`;
    canvas.style.left = "10px";
    canvas.style.width = `${chartWidth - rightPadding}px`;
    canvas.style.height = `${chartHeight}px`;

    const hasData = processed.dataPoints.some(p => p !== null);
    if (!hasData){
      ctx.clearRect(0,0,canvas.width,chartHeight);
      ctx.font = "18px Times New Roman";
      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(2,6,23,.45)";
      ctx.fillText("No data available for current filters", canvas.width/2, chartHeight/2);
      return;
    }

    const allVals = processed.dataPoints.flatMap(p => p ? [p.min, p.avg, p.max] : []);
    const dataMax = Math.max(...allVals);
    const dataMin = Math.min(...allVals);
    const range = Math.max(1e-9, dataMax - dataMin);
    const suggestedYMax = Math.ceil(dataMax + range * 0.1);
    const suggestedYMin = Math.max(0, Math.floor(dataMin - range * 0.1));
    const hierarchyInfo = processed.hierarchyInfo || [];
    const tooltipData = processed.dataPoints.map(dp => dp ? [dp.min, dp.max] : null);

    charts[metricKey] = new Chart(ctx, {
      type: "bar",
      data: {
        labels: processed.labels,
        datasets: [{
            label: "",
            data: tooltipData,
            backgroundColor: "rgba(0,0,0,0.001)", // Almost transparent for hit test
            borderColor: "transparent",
            borderWidth: 0,
            barPercentage: 0.8,
            categoryPercentage: 0.9,
            hoverBackgroundColor: "rgba(0,0,0,0.05)", // Slight gray on hover to confirm interaction
            order: 1
        }]
      },
      options: {
        responsive: false,
        maintainAspectRatio: false,
        animation: false,
        layout: { 
          padding: { 
            top: 0, bottom: 0, 
            left: parseFloat(style.getPropertyValue('--yGutter').trim()) || 60, 
            right: 12 
          } 
        },
        scales: {
          y: {
            beginAtZero: false, min: suggestedYMin, max: suggestedYMax,
            grid: { color: "rgba(2,6,23,.10)", drawBorder: false },
            title: { display: true, text: title, padding: { top: 0, bottom: 20 }, font: { family: "Times New Roman", size: 12, weight: 'bold' } },
            ticks: { display: false, padding: 10 },
            afterFit: function(scale) { scale.width = 50; }
          },
          x: {
            display: true, ticks: { display: false }, grid: { display: false },
            border: { display: true, color: "rgba(2,6,23,.35)", width: 2 },
            offset: false,
            afterFit: function(scale) { scale.left = parseFloat(style.getPropertyValue('--yGutter').trim()) || 60; }
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: false,
            external: function(context) {
              const tooltipModel = context.tooltip;
              if (tooltipModel.opacity === 0) {
                clearTooltip();
                return;
              }
              if (tooltipModel.dataPoints && tooltipModel.dataPoints.length > 0) {
                const index = tooltipModel.dataPoints[0].dataIndex;
                const dp = processed.dataPoints[index];
                if (dp) {
                  showCustomTooltip(context.chart, index, hierarchyInfo, dp, document.getElementById(scrollId));
                }
              }
            }
          }
        },
        interaction: { mode: 'index', intersect: false },
        onHover: (event, active) => {
          event.native.target.style.cursor = active.length ? "pointer" : "default";
        }
      },
      plugins: [{
        id: "rangeOverlay",
        afterDatasetsDraw: (chart) => {
          const meta = chart.getDatasetMeta(0);
          const yScale = chart.scales.y;
          clearValueBoxes(scrollEl); // Careful, this clears previous tooltips too
          
          let barWidth = 80;
          if (meta.data.length > 1) {
            barWidth = Math.abs(meta.data[1]?.x - meta.data[0]?.x) || 80;
          }

          processed.dataPoints.forEach((dp, idx) => {
            const el = meta.data[idx];
            if (!dp || !el) return;
            const x = el.x;
            const minY = yScale.getPixelForValue(dp.min);
            const maxY = yScale.getPixelForValue(dp.max);
            const avgY = yScale.getPixelForValue(dp.avg);
            const c = chart.ctx;
            c.save();
            c.strokeStyle = "rgba(2,6,23,.90)";
            c.lineWidth = 2;
            c.beginPath();
            c.moveTo(x, minY);
            c.lineTo(x, maxY);
            c.stroke();
            c.restore();

            // Value Boxes
            const mkBox = (text, left, top, cls) => {
              const canvasOffsetTop = canvas.offsetTop;
              const canvasOffsetLeft = canvas.offsetLeft;
              const adjustedLeft = left + canvasOffsetLeft;
              const adjustedTop = top + canvasOffsetTop;
              const d = document.createElement("div");
              d.className = `candlestick-value-box ${cls || ""}`.trim();
              d.textContent = text;
              d.style.left = `${adjustedLeft}px`;
              d.style.top = `${adjustedTop}px`;
              scrollEl.appendChild(d);
            };
            mkBox(formatNumber(dp.min), x, minY, "");
            mkBox(formatNumber(dp.max), x, maxY, "");
            mkBox(formatNumber(dp.avg), x, avgY, "avg");
          });
          buildHierLabels(labelsEl, processed.labelHierarchy, chart, meta, barWidth);
        }
      }]
    });
    
    setTimeout(() => {
      if (charts[metricKey]) {
        const meta = charts[metricKey].getDatasetMeta(0);
        let barWidth = 80;
        if (meta.data.length > 1) barWidth = Math.abs(meta.data[1]?.x - meta.data[0]?.x) || 80;
        buildHierLabels(labelsEl, processed.labelHierarchy, charts[metricKey], meta, barWidth);
      }
    }, 100);
  }

  function recalcHierarchyOptions() {
    const finOpts = uniqSorted(rawRows.map(r => norm(r.finishing_specs)));
    setOptions(hfFinishing, finOpts, hfFinishing.value || ALL);
    const fin = hfFinishing.value || ALL;
    const rowsFin = (fin === ALL) ? rawRows : rawRows.filter(r => norm(r.finishing_specs) === fin);
    const devOpts = uniqSorted(rowsFin.map(r => norm(r.developer_name)));
    setOptions(hfDeveloper, devOpts, hfDeveloper.value || ALL);
    const dev = hfDeveloper.value || ALL;
    const rowsDev = (dev === ALL) ? rowsFin : rowsFin.filter(r => norm(r.developer_name) === dev);
    const projOpts = uniqSorted(rowsDev.map(r => norm(r.project_name)));
    setOptions(hfProject, projOpts, hfProject.value || ALL);
    const proj = hfProject.value || ALL;
    const rowsProj = (proj === ALL) ? rowsDev : rowsDev.filter(r => norm(r.project_name) === proj);
    const payOpts = uniqSorted(rowsProj.map(r => norm(r.payment_yrs)));
    setOptions(hfPayment, payOpts, hfPayment.value || ALL);
    [hfFinishing, hfDeveloper, hfProject, hfPayment].forEach(s => s.disabled = false);
    animate(hierPanel);
  }

  function renderAll() {
    const rows = filteredRowsByHierarchy(rawRows);
    const crumb = selectionCrumb();
    crumbPrice.textContent = crumb; crumbBUA.textContent = crumb; crumbPSM.textContent = crumb;
    rowsChipPrice.textContent = `${rows.length} rows`; rowsChipBUA.textContent = `${rows.length} rows`; rowsChipPSM.textContent = `${rows.length} rows`;

    const priceProcessed = flattenWithHierarchy(buildHierarchy(rows, "unit_price"), "price");
    const buaProcessed   = flattenWithHierarchy(buildHierarchy(rows, "bua"), "bua");
    const psmProcessed   = flattenWithHierarchy(buildHierarchy(rows, "psm"), "psm");

    renderRangeChart({ canvasId: "priceChart", scrollId: "priceScroll", labelsId: "priceLabels", processed: priceProcessed, metricKey: "price"});
    renderRangeChart({ canvasId: "buaChart", scrollId: "buaScroll", labelsId: "buaLabels", processed: buaProcessed, metricKey: "bua"});
    renderRangeChart({ canvasId: "psmChart", scrollId: "psmScroll", labelsId: "psmLabels", processed: psmProcessed, metricKey: "psm"});

    animate(document.getElementById("priceContainer"));
    animate(document.getElementById("buaContainer"));
    animate(document.getElementById("psmContainer"));
  }

  async function loadData() {
    const location = gfLocation.value.trim();
    const asset_type = gfAsset.value.trim();
    const unit_type = gfUnit.value.trim();
    const shouldLoad = !!(location || asset_type || unit_type);

    if (!shouldLoad) {
      rawRows = [];
      loadChip.textContent = "No data loaded";
      emptyState.style.display = "block";
      hierPanel.style.display = "none";
      chartsSection.style.display = "none";
      return;
    }

    if (controller) controller.abort();
    controller = new AbortController();
    loadingRow.classList.add("show");
    loadChip.textContent = "Loadingâ€¦";
    [hfFinishing, hfDeveloper, hfProject, hfPayment].forEach(s => { s.disabled = true; s.innerHTML = ""; });

    const params = new URLSearchParams();
    if (location) params.set("location", location);
    if (asset_type) params.set("asset_type", asset_type);
    if (unit_type) params.set("unit_type", unit_type);

    try {
      const res = await fetch(`${DATA_URL}?${params.toString()}`, { signal: controller.signal });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const payload = await res.json();
      rawRows = (payload.items || []).map(r => ({
        finishing_specs: norm(r.finishing_specs),
        developer_name: norm(r.developer_name),
        project_name: norm(r.project_name),
        payment_yrs: norm(r.payment_yrs),
        unit_price: r.unit_price, bua: r.bua, psm: r.psm,
      }));
      const c = payload.count ?? rawRows.length;
      loadChip.textContent = `${c} rows loaded`;
      emptyState.style.display = rawRows.length ? "none" : "block";
      hierPanel.style.display = rawRows.length ? "block" : "none";
      chartsSection.style.display = rawRows.length ? "flex" : "none";
      hfFinishing.value = ALL; hfDeveloper.value = ALL; hfProject.value = ALL; hfPayment.value = ALL;
      recalcHierarchyOptions();
      renderAll();
      ["priceWrapper","buaWrapper","psmWrapper"].forEach(id => { const w = document.getElementById(id); if (w) { w.scrollLeft = 0; w.scrollTop = 0; } });
    } catch (e) {
      if (e.name !== "AbortError") {
        console.error(e);
        rawRows = [];
        loadChip.textContent = "Load failed";
        emptyState.style.display = "block";
        hierPanel.style.display = "none";
        chartsSection.style.display = "none";
      }
    } finally {
      loadingRow.classList.remove("show");
    }
  }

  let debounceT = null;
  function debouncedLoad(){ if (debounceT) clearTimeout(debounceT); debounceT = setTimeout(loadData, 120); }
  [gfLocation, gfAsset, gfUnit].forEach(el => el.addEventListener("change", debouncedLoad));
  resetBtn.addEventListener("click", () => { gfLocation.value = ""; gfAsset.value = ""; gfUnit.value = ""; loadData(); });
  hfFinishing.addEventListener("change", () => { hfDeveloper.value = ALL; hfProject.value = ALL; hfPayment.value = ALL; recalcHierarchyOptions(); renderAll(); });
  hfDeveloper.addEventListener("change", () => { hfProject.value = ALL; hfPayment.value = ALL; recalcHierarchyOptions(); renderAll(); });
  hfProject.addEventListener("change", () => { hfPayment.value = ALL; recalcHierarchyOptions(); renderAll(); });
  hfPayment.addEventListener("change", () => renderAll());

  (function initFromQuery(){
    const q = new URLSearchParams(window.location.search);
    const loc = q.get("location") || "";
    const at  = q.get("asset_type") || "";
    const ut  = q.get("unit_type") || "";
    if (loc) gfLocation.value = loc;
    if (at)  gfAsset.value = at;
    if (ut)  gfUnit.value = ut;
    if (loc || at || ut) loadData();
  })();
})();
</script>

{% endblock %}

